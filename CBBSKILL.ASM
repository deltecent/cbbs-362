;CBBS V3.6.2 	CBBSKILL.ASM - MESSAGE KILL
;07/03/83 12:53:09
;	LINKS TO CBBSDISK
;
;	O   O	O O O	O	O
;	O  O	  O	O	O
; CBBS	O O	  O	O	O	.ASM
;	O  O	  O	O	O
;	O   O	O O O	O O O	O O O
;
;MODIFICATIONS LOG: (THRU 3.2 WRITTEN TO "HISTORY")
;07/03/83 When asking Y/N OK to kill, take C/R to mean "no".
;	This will allow hanging up on carrier loss.
;
;====> HISTORICAL COMMENTS SINCE 3.3 TO "HISTORY.033"
;	then "history.036"
;
;-----> FUNCTION TO KILL A MESSAGE
;
KILL	mvi	a,1	;set 1st time sw allowing
	sta	tries	; stacked kills (k;nn;nn;nn)
	LDA	NKILATT	;GET # ATTEMPTS
	CPI	3	;3 ALREADY?
	JZ	nofunc	;ACT LIKE KILL IS UNKNOWN
;
;	new entry point 02/27/83 to support k;nn;nn;nn
;
kill2	CALL	GETVAR
	DB	'Msg # to kill: '
	DB	'(C/R if none)',0
	DW	ANSWER
	DW	00	;HELP MSG #
	DB	5
	LDA	ANSWER
	CPI	CR
	JZ	FUNCT
	XRA	A	;SHOW NO PASS-
	STA	PASSWD	;	WORD ENTERED
	lxi	h,tries
	mov	a,m		;get old switch
	mvi	m,0		;set to 0
	ora	a
	cnz	justa		;justify full number
	JC	KILL	;INVALID #
	lxi	h,answer
	CALL	JUSTR	;R. JUST. ANS. INTO 'MSGNO'
;
	LDA	PASSFLG	;SKIP "LOOKING.."
	ORA	A	;	IF
	JZ	KNLOOK	;	OPERATOR
;
	IF	TWITCK
	CALL	TWITST
	JZ	klogk
	LDA	TWITSW	;DON'T LET
	ORA	A	;	A 'TWIT'
	JNZ	klogk	;	KILL A MSG
	ENDIF
;
 if msgapp
	call	ckhiapp
	jc	klook
	call	kpnotf
	jmp	funct
 endif
klook	CALL	ILPRT
	DB	'Looking...',CR,LF,0
KNLOOK	MVI	A,ctlkoff	;DISABLE CTL-K
	STA	CTLKSW
	STA	DKUPSW	;ALSO SHOW UPDATING DISK
;
;KILL THE MESSAGE
;
	CALL	SETMSGN	;SET UP FILE NAME
	LXI	H,MSGFN ;GET NAME POINTER
	CALL	KILLMSG	;KILL MESSAGE
;
;FLAG THE SUMMARY (OPERATOR "PURGE" COMMAND
;	DELETES FLAGGED SUMMARIES)
;
	CALL	FLAGSUM	;FLAG MSG IN SUMMARY FILE
;
;	N-O-T-E: Following code allows stacked kills as a
;	list of numbers, using shorthand, i.e. k;1234;5;6
;	but is OPERATOR ONLY.  If you want to allow everyone
;	to do this, change LDA PASSFLG to JMP KILLMOR
;
kckmore	LDA	PASSFLG
	ORA	A
	JZ	KILLMOR	;OPERATOR NEEDS NO CR/LF, MAY
			;	HAVE MORE TO KILL
	LDA	INBUF
	CPI	CR
	CNZ	CRLF	;CRLF IF STACKED COMMAND
	JMP	FUNCT
;
; routine to see if operator stacked more msgs to kill
; allows shorthanding kills - k;1234;5;6;1256 etc.
;
killmor	lda	inbuf		;stacked lines?
	cpi	cr
	jz	funct		;	no.
	call	ck09
	jc	funct
	jmp	kill2		;go kill another
;
;---->	SUBROUTINE TO KILL A MESSAGE FROM A
;FILE.  HL POINTS TO FILENAME.  FILE IS
;TRANSFERRED TO "WORKFILE", ERASED, THEN
;THE WORKFILE RENAMED TO THE MSG OR SUMMARY
;FILE NAME.
;
KILLMSG	CALL	SETRD	;SETUP FCB, OPEN
	JC	KNOTF	;NOT FOUND
;
	CALL	KSETUP	;MAKE .BAK FILE, ETC
KNEXT	CALL	KREAD1	;READ 1 MSG OR SUMMARY
	JC	KNOTF
	CALL	KCHECK	;IS THIS IT?
	JZ	KGOTIT	;GOT IT
03	JC	KNOTF	;PAST IT, NO MATCH
	CALL	KWRITE1	;WRITE 1 MSG OR SUMMARY
	JMP	KNEXT
;
;TYPE THE HEADER AS VALIDATION
;
KGOTIT	CALL	KSHOW	;SHOW HDR
;
;SKIP VERIFY IF OPERATOR
;
	LDA	PASSFLG
	ORA	A
	JZ	KTRANS	;07/19/81 DON'T TELL OPERATOR
;			 "UPDATING.."
;
;OK, SEE IF THIS IS TO BE ERASED.
;SAVE HL, AS IT POINTS TO PASSWORD
;
	PUSH	H
;
;09/13/81 MODS TO NOT CALL GETVAR, TO PRESERVE STACKED
;		KILL REQUESTS
;
KVERIFY	CALL	ILPRX	;EXPERT PROMPT
	DB	'Y/N OK: to erase it? ',0
	CALL	KEYIN
	PUSH	PSW
	mov	b,a
	lda	echoflg
	ora	a
	mov	a,b
	cnz	type		;echo if full duplex
	CALL	CRLF
	POP	PSW
	ANI	5FH
	CPI	CR
	JZ	KFIXUP		;07/03/83 mod
	CPI	'N'
	JZ	KFIXUP
	CPI	'Y'
	JZ	KVOK
	MVI	A,CR	;KILL
	STA	INBUF	;	STACKED LINES
	JMP	KVERIFY
;
;	KSHOW - TYPES HEADER IN KILLBUF
;
KSHOW	LXI	H,KILLBUF+1 ;TO MSG
	MVI	B,5	;TYPE THRU 5 COMMAS
	MVI	A,' '
KSHOWLP	CALL	TYPE
	MOV	A,M
	INX	H
	CPI	','
	JNZ	KSHOWLP	;NOT COMMA
	DCR	B
	JNZ	KSHOWLP
	JMP	CRLF	;AND RETURN
;
;NOW CHECK THE PASSWORD
;
KVOK	POP	H
;
;SEE IF NO PASSWORD.
;
	MOV	A,M
	CPI	CR	;NO PASSWORD?
	JZ	KUPDATE	;OK, WRITE OUT REST
;
;CHECK FOR SYSTEM PASSWORD
;
	PUSH	H	;SAVE PW POINTER
	LXI	D,NONE
	MVI	B,4
	CALL	COMPR
	JZ	KSYSPAS	;NO KILL ALLOWED
;
;USER KILL ALLOWED, BUT PASSWORD PRESENT.  GET IT.
;
	CALL	GETVAR
	DB	CR,LF
	DB	'Enter password',0
	DW	PASSWD
03	DW	00	;HELP MSG #
	DB	4
	POP	H
	LXI	D,PASSWD
	MVI	B,4
	CALL	COMPR	;MATCH?
	JNZ	KBADPAS	;	NO, BAD PASSWORD
;
KUPDATE	CALL	ILPRT
	DB	'Updating: Msg, ',0
;
;TRANSFER REST OF FILE TO WORK FILE
;
KTRANS	CALL	RDBYTE
	PUSH	PSW	;SAVE EOF IND.
	CALL	KWRBYTE
	POP	PSW
	JNC	KTRANS	;NOT EOF
;
;EOF ON TRANSFER
;	
	CALL	KFLUSH	;FLUSH BUFFERS
	CALL	KRENAME	;RENAME, ERASE
;
;LOG IT TO THE KILLED FILE
;
	LDA	PASSFLG	;BUT DON'T WASTE
	ORA	A	;	OPERATOR
	JZ	KNOHIST	;	TIME
;
	CALL	ILPRT
	DB	'history file, ',0
;
;IT'S MSG, LOG IT TO THE KILLED FILE.
;
KNOHIST	CALL	KDMA80	;RESET DMA TO 80H
	LXI	H,MSGLGFL ;POINT TO FILENAME
	CALL	EXTEND	;EXTEND IT
	MVI	A,']'	;ALLOW CTL-C TO SKIP
	CALL	WRBYTE	;	TO NEXT MSG
	LXI	H,FNAME
	CALL	WRVARC	;WRITE FIRST NAME,
	LXI	H,LNAME ;
	CALL	WRVARC	;	LAST NAME,
 IF CLOCK
	CALL	WRTIME	;DATE/TIME
 ENDIF
	CALL	WRCRLF	;CRLF
	LXI	H,KILLBUF
KLOGLPL	INX	H	;SKIP BELL
	MOV	A,M	;GET CHAR
	CPI	EOF
	JZ	KLOGEND	;END
	CPI	7	;BELL?
	JZ	KLOGEND
	CALL	WRBYTE
	JMP	KLOGLPL	;LOOP WRITING MSG
;
;END OF MSG
;
KLOGEND	CALL	WREOF	;WRITE EOF, CLOSE
	LDA	PASSFLG
	ORA	A
	JZ	KNOACT
	CALL	ILPRT
	DB	'# of active msgs, ',0
KNOACT	CALL	RDNEXT
	LXI	H,nxlnmsg	;UNITS of next msg #
	CALL	SUB1	;SUBTRACT 1 IN ASCII
	XRA	A
	STA	FCBRNO	;REWRITE REC 0
	LXI	D,FCB
	MVI	C,WRITE
	CALL	BDOS
	ORA	A	;WRITE OK?
	jz	closenx	;	yes, close NEXT file
	JMP	TELLUS	;	no, tell of error
;
;SETUP FOR KILL:
;	MAKE .BAK FILE
;	SET UP BUFFER POINTERS
;
KSETUP	CALL	KMAKE	;SET DMA TO .BAK
	LXI	H,MSGBF
	SHLD	WKBFA	;SET WRITE BUFFER ADDR
	LXI	H,0
	SHLD	WKCOUNT	;# BYTES TO WRITE
	RET
;
;MAKE THE .BAK FILE
;
KMAKE	CALL	KDMAWK	;DMA ADDR TO WK
	XRA	A
	STA	WKEXT	;EXTENT
	STA	WKRNO	;REC #
	LXI	D,WKFCB
	PUSH	D
	MVI	C,ERASE	;ERASE
	CALL	BDOS	;	JUST IN CASE
	POP	D
	MVI	C,MAKE
	CALL	BDOS
	PUSH	PSW
	CALL	KDMA80
	POP	PSW
	INR	A
	RNZ
KFULL	CALL	ILPRT
	DB	'++ERR: DISK OR DIR. FULL!!++'
	DB	CR,LF,0
KERXIT	CALL	KDMA80	;RESET DMA TO 80H
	JMP	TELLUS
;
;DIDN'T FIND A BELL HEADER
;
KFMTERR	CALL	ILPRT
	DB	'++ERR IN MSG FILE FMT++'
	DB	CR,LF,0
	JMP	KERXIT
;
;CHECK IF MSG/SUMM READ MATCHES
;
KCHECK	LXI	D,MSGNO
	LXI	H,KILLBUF+1
	MVI	B,5	;MSG # LENGTH
	CALL	COMPR
	RET
;
;SET DMA TO WORK BUFFER
;
KDMAWK	LXI	D,WKBUF
04;:
KDMA	MVI	C,SETDMA
	CALL	BDOS
	RET
;
;SET DMA TO 80H
;
KDMA80	LXI	D,80H
	JMP	KDMA
;
;READ ONE MESSAGE OR SUMMARY INTO MEMORY
;
KREAD1	LXI	H,KILLBUF
	CALL	RDBYTE	;ENSURE 1ST
	MOV	M,A	;	BYTE IS BELL
	INX	H	;	(OR MAY BE
	RC		;	EOF)
	CPI	7
	JNZ	KFMTERR	;FORMAT ERROR: NO BELL
KR1LP	LDA	7	;GET BDOS ADDR
	DCR	A	;BACK 1 PAGE
	CMP	H
	JZ	KNOFIT	;MSG WON'T FIT
	CALL	RDBYTE
	MOV	M,A
	CPI	EOF	;NO CARRY ON EOF
	RZ		;	'CAUSE MSG FOUND
	INX	H
	CPI	7	;BELL HDR OF NEXT?
	JNZ	KR1LP
;
;GOT NEXT MSGS BELL HEADER
;
	CALL	UNRDBYT	;PUT BELL BACK
	ORA	A	;NO CARRY, NOT EOF
	RET
;
;WRITE ONE MSG/SUMM BACK TO WORK FILE.
;(MIGHT ONLY BE A BUFFER-BUFFER TRANSFER)
;
KWRITE1	LXI	H,KILLBUF
KWR1LP	MOV	A,M
	CALL	KWRBYTE
	INX	H
	MOV	A,M
	CPI	EOF
	RZ
	CPI	7	;NXT MSG HDR?
	JNZ	KWR1LP
	RET
;
;BUFFERED WRITE TO WORK FILE
;
KWRBYTE	PUSH	H
	LHLD	WKBFA
	MOV	M,A
	INX	H
	SHLD	WKBFA
	LHLD	WKCOUNT
	INX	H
	SHLD	WKCOUNT
	MOV	A,H
	CPI	KBUFPG	;BUFF FILLED?
	CZ	KWRITE	;DO PHYS WRITE
	POP	H
	RET
;
;FLUSH THE WRITE BUFFERS, CLOSE THE FILE
;
KFLUSH	CALL	KWRITE
	CALL	KDMAWK
	LXI	D,WKFCB
	MVI	C,CLOSE
	CALL	BDOS
	PUSH	PSW
	CALL	KDMA80
	POP	PSW
	INR	A
	RNZ
	JMP	KFULL
;
;PHYSICAL WRITE TO WORK FILE, FROM BUFFER
;
KWRITE	LHLD	WKCOUNT	;GET # BYTES
	DCX	H	;BACK OUT LAST INX
	DAD	H	;H=# SECTORS
	MOV	B,H
	INR	B	;ALLOW DCR B LOOP.
	LXI	D,MSGBF
KWRITEL	PUSH	B
	PUSH	D
04	MVI	C,SETDMA
	CALL	BDOS
	LXI	D,WKFCB
	MVI	C,WRITE
	CALL	BDOS
	ORA	A
	JNZ	KFULL
	POP	D
	POP	B
	LXI	H,80H
	DAD	D
	XCHG		;TO NEXT BUF
	DCR	B
	JNZ	KWRITEL
	LXI	H,0	;RESET
	SHLD	WKCOUNT	;	COUNT
	LXI	H,MSGBF	;RESET
	SHLD	WKBFA	;	BUFF ADDR
	CALL	KDMA80
	RET
;
;ERASE THE FILE, RENAME THE WORK FILE
;TO THE FILE NAME.
;
KRENAME	CALL	KDMA80
	LXI	D,FCB
	MVI	C,ERASE
	CALL	BDOS
	XRA	A
	STA	FCBEXT
	STA	WKEXT
	LXI	H,FCB	;SETUP NAME
	LXI	D,WKFCB+16 ;FOR RENAME
	MVI	B,16
	CALL	MOVE
	LXI	D,WKFCB
	MVI	C,REN
	CALL	BDOS
	INR	A
	RET		;ADDED INSTR, SEE BELOW
;
;FOLLOWING IGNORED - CP/M ALWAYS SAYS
;RENAME FAILED, (DON'T KNOW WHY)
;
;	RNZ
;	CALL	ILPRT
;	DB	'++RENAME FAILED++',CR,LF,0
;	RET
;
;MESSAGE NOT FOUND
;
KNOTF	call	kpnotf
KFIXUP	CALL	KDMAWK
	LXI	D,WKFCB	;CLOSE THE
	MVI	C,CLOSE	;	WORK FILE
	CALL	BDOS	;(WRITES ALLOC TO DISK)
	LXI	D,WKFCB	;ERASE THE
	MVI	C,ERASE	;	WORK FILE
	CALL	BDOS	;	AND FREE ALLOC.
	CALL	KDMA80
	JMP	kckmore	;if oper, see if more msgs

kpnotf	CALL	ILPRT
	DB	'++Not found++',CR,LF,0
	ret
;
;PASSWORD INCORRECT
;
KBADPAS	CALL	ILPRT
	DB	'++Wrong password++',CR,LF,0
	JMP	KLOGK
;
;USER TRIED TO KILL MSG W/SYSTEM PASSWORD 'NONE'
;
KSYSPAS	CALL	ILPRT
	DB	CR,LF
	DB	'++Operator killable only++'
	DB	CR,LF,0
;
;11/11/78 LOG ATTEMPT TO KILL, UNSUCCESSFULLY
;
KLOGK	CALL	KDMA80	;DMA=80H
	LXI	H,LOGFL ;POINT TO FILE
	CALL	EXTEND
	CALL	WRCRLF	;SEND CRLF
	MVI	A,']'
	CALL	WRBYTE
	MVI	A,'K'
	CALL	WRBYTE
	MVI	A,','
	CALL	WRBYTE
	LXI	H,MSGNO
	CALL	WRVARC	;WRITE MSG #
	CALL	WRNAME
	mvi	a,' '
	call	wrbyte
	CALL	WREOF	;CLOSE THE FILE
	CALL	ILPRT
	DB	'I told operators you want that msg killed.'
	DB	CR,LF,0
;
	LXI	H,MSGNO		;if killing msg < 10,
	LXI	D,OOOO1		;make 'em a twit & hang up.
	CALL	COMP4
	JNZ	KBK		;	ok, not 1-9
;
;	10/19/82 added logic to make this person a twit,
;	by writing '[firstname,lastname,]*crlf
;	to "NEXT" file.
;
	lxi	h,nextfl
	call	extend
	mvi	a,'['	! call wrbyte
	lxi	h,fname ! call wrvarc
	lxi	h,lname ! call wrvarc
	mvi	a,']'	! call wrbyte
	mvi	a,'*'	! call wrbyte
	call	wrcrlf
	call	wreof
	jmp	DISC	;BYE, TWIT!
;
;BUMP COUNT OF UNSUCCESSFUL ATTEMPTS
;
kbk	LXI	H,NKILATT
	INR	M
	JMP	KFIXUP
;
OOOO1	DB	'00001'
;
;MSG WON'T FIT IN MEMORY
;
KNOFIT	CALL	ILPRT
	DB	'++MSG TOO BIG TO KILL++',CR,LF,0
	JMP	KFIXUP
;
;	PURGE FLAGGED MSGS FROM SUMMARY FILE,
;	(OPERATOR "PURGE" COMMAND)
;
PURGE	LXI	H,SUMFL
	CALL	SETRD	;SETUP FCB, OPEN
	JC	NOSUM	;NOT FOUND
	XRA	A	;INIT
	STA	NPURG	;	COUNT PURGED
;
	CALL	KSETUP	;MAKE .BAK FILE, ETC
PURNXT	CALL	KREAD1	;READ 1 MSG OR SUMMARY
	JC	PURGEOF
	LDA	KILLBUF+7
	CPI	'X'	;FLAGGED?
	JZ	PURX	;YES, SKIP IT
	CALL	KWRITE1	;WRITE IT TO WORKFILE
	JMP	PURNXT
;
PURGEOF	MVI	A,EOF
	CALL	KWRBYTE
	CALL	KFLUSH	;WRITE IT BACK
	CALL	KRENAME	;RENAME WORK FILE
	LDA	NPURG
	CALL	PRDEC
	CALL	ILPRT
	DB	' Purged',CR,LF,0
	JMP	FUNCT	;DONE
;
PURX	LXI	H,NPURG	;BUMP COUNT PURGED
	INR	M
	LDA	ANSWER+5 ;WAS IT PURGEN?
	CPI	'N'
	CNZ	KSHOW	;SHOW THE HDR
	JMP	PURNXT
;
;	FLAG SUMMARY ENTRY AS DELETED
;
FLAGSUM	LDA	PASSFLG	;NO PRINT
	ORA	A	;	IF
	JZ	FLAGSNP	;	OPERATOR
	CALL	ILPRT
	DB	'& Summary..',0
FLAGSNP	CALL	BINSRCH	;POSITION TO SECTOR
FLAGLP	CALL	BINCOMP	;DO EXACT MATCH
	JZ	FLAGIT
	JC	FLAGLP	;NOT THERE YET
FLAGNF	CALL	ILPRT
	DB	'Not found??',0
	RET
;
FLAGIT	CALL	RDBYTE	;READ THE COMMA
	CPI	','
	JNZ	FLAGNF
	CALL	RDBYTE	;GET #
	CALL	UNRDBYT	;BACK IT OUT
	MVI	A,'X'	;FLAG IT
	LXI	H,FCBRNO ;POINT TO REC #
	DCR	M	;BACK UP FOR WRITE
	CALL	WRBYTE
;
;JUST IN CASE "WRBYTE" WROTE THE 128TH
;BYTE, IT ALSO DID THE PHYSICAL WRITE.
;
	LDA	BUFPTR
	CPI	80H
	RZ		;WRITE ALREADY DONE
	LXI	D,FCB
	MVI	C,WRITE
	CALL	BDOS	;RE-WRITE REC.
	ORA	A
	RZ
	CALL	ILPRT
	DB	'++WRITE ERROR',CR,LF,0
	JMP	TELLUS
;
	LINK	CBBSDISK ;TO NEXT .ASM FILE
                                                                                                     