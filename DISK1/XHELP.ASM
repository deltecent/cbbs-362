;Name:          XHELP.ASM
;Author:        Ward Christensen
;Written:       10/11/81
;Function:      To build an index into the HELP file
;		of CBBS.
;               
;               
;Processor:     ASM
;Dependencies:  None.
;Revs (last first):
;               None.
;Usage:		INDXHELP with the logged in disk
;		containing "HELP".  HELP.IDX will be
;		written to the logged in disk

;	================
;
CR	EQU	0DH
LF	EQU	0AH
EOF	EQU	1AH
;
;START OF PROGRAM EXECUTION
;
	ORG	100H	
	CALL	INIT	;INIT THINGS
	CALL	OPNHELP	;OPEN THE FILE
	CALL	BLDX	;BUILD THE INDEX
	CALL	MAKIDX	;MAKE THE INDEX
	CALL	WRIDX	;WRITE IT
	CALL	CLOSIDX	;CLOSE IT
	CALL	MSGEXIT
	DB	'++DONE++$'
;================
;INIT THINGS
;
INIT	POP	B	;GET INIT RET ADDR
	LXI	H,0
	DAD	SP	;GET CP/M STACK
	SHLD	STACK
	LXI	SP,STACK
	PUSH	B	;PUT BACK RET ADDR
	RET
;================
;OPEN THE FILE
;
OPNHELP	LXI	D,HELPFCB
	MVI	C,OPEN
	CALL	BDOS
	INR	A
	RNZ
	CALL	ERXIT
	DB	'++NO HELP FILE ON LOGGED IN DISK++$'
;================
;BUILD THE INDEX
;
;
BLDX	LXI	D,100H	;INIT TO FORCE READ
	LXI	H,BUFF
	MVI	M,CR	;STORE INITIAL CR/F
	INX	H	;	BECAUSE CBBS
	MVI	M,LF	;	LOOKS FOR A WORD
	INX	H	;	BEGINNING AFTER LF.
BXLOOP	MVI	A,EOF
	MOV	M,A	;STORE POSSIBLE EOF
	CALL	RDBYTE
	CPI	EOF
	RZ
	CPI	'['	;KEYWORD START?
	JNZ	BXLOOP
;
;GOT A KEYWORD
;
	LDA	HELPFCB+RNO ;GET REC #
	DCR	A	;READ INR'D IT, UNDO THAT

	PUSH	PSW	;SAVE IT
	LDA	HELPFCB+EXT ;GET EXTENT
	PUSH	PSW
;
BXLOOP2	CALL	RDBYTE	;GET NEXT BYTE
	CPI	EOF
	JZ	ERROR
	CPI	CR
	JZ	ERROR
	CPI	'='	;END OF KW?
	JZ	BXENDK
	MOV	M,A
	INX	H
	LDA	BDOS+2
	DCR	A
	CMP	H
	JNZ	BXLOOP2
	CALL	ERXIT
	DB	'++MEMORY FULL READING KEYWORDS++$'
;
;END OF KEYWORD - STORE ADDRESSES
;
BXENDK	MVI	M,','	;DELIMITER
	INX	H
	POP	PSW	;GET EXTENT
	CALL	NIBBL	;GET RIGHT BYTE, STORE IT
	MOV	M,A	;STORE IT
	POP	PSW	;GET RECORD #
	PUSH	PSW	;PUT IT BACK
	RAR ! RAR ! RAR ! RAR
	CALL	NIBBL
	POP	PSW
	CALL	NIBBL	;LAST BYTE
	MVI	M,CR
	INX	H
	MVI	M,LF
	INX	H
	JMP	BXLOOP
;
ERROR	CALL	ERXIT
	DB	'++EOF IN MIDDLE OF KEYWORD IN HELP FILE++$'
;
;================
;STORE A NIBBL INTO MEMORY IN PRINTABLE HEX
;
NIBBL	ANI	0FH	;GET 4 BITS
	ADI	90H
	DAA
	ACI	40H
	DAA
	MOV	M,A	;STORE IT
	INX	H	;TO NEXT
	RET
;
;================
;RDBYTE - DE POINTS TO NEXT BYTE TO READ.
;	USES DEFAULT BUFFER AT 80H
;
RDBYTE	LDAX	D	;GET (POSSIBLE) BYTE
	INR	E	;BUMP POINTER
	RZ		;RETURN IF LAST BYTE IN SECTOR
	RM		;	OR STILL IN SECTOR
;
	PUSH	H	;HAVE TO READ...
	LXI	D,HELPFCB
	MVI	C,READ
	CALL	BDOS
	POP	H
	LXI	D,80H	;INIT BUFFER POINTER
	ORA	A
	JZ	RDBYTE
	DCR	A	;EOF?
	MVI	A,EOF
	RZ
	CALL	ERXIT
	DB	'++ERROR READING "HELP"++$'
;================
;MAKE THE INDEX
;
MAKIDX	LXI	D,INDXFCB
	MVI	C,ERASE
	CALL	BDOS
	LXI	D,INDXFCB
	MVI	C,MAKE
	CALL	BDOS
	INR	A
	RNZ
	CALL	ERXIT
	DB	'++CAN''T MAKE HELP.IDX ON LOGGED IN DISK++$'
;
;================
;WRITE IT
;
WRIDX	LXI	H,BUFF	;POINT TO BUFFER
	LXI	D,80H	;INIT WRITE POINTER
;
WRLP	MOV	A,M
	CALL	WRBYTE
	MOV	A,M
	INX	H
	CPI	EOF
	JNZ	WRLP
	CALL	WRSEC
	RET
;
;================
;WRITE A BYTE TO THE INDEX FILE
;
WRBYTE	STAX	D
	INR	E
	RNZ		;NOT AT 100H YET
;
;HAVE TO WRITE THE SECTOR
;
WRSEC	PUSH	H
	LXI	D,INDXFCB
	MVI	C,WRITE
	CALL	BDOS
	POP	H
	LXI	D,80H	;SET UP FOR NEXT WRITE
	ORA	A
	RZ
	CALL	ERXIT
	DB	'++WRITE ERROR++$'
;
;================
;CLOSE IT
;
CLOSIDX	LXI	D,INDXFCB
	MVI	C,CLOSE
	CALL	BDOS
	INR	A
	RNZ
	CALL	ERXIT
	DB	'++CLOSE ERROR ON HELP.IDX++$'
;
;================
;EXIT WITH ERROR MESSAGE
;
MSGEXIT	EQU	$	;EXIT W/"INFORMATIONAL" MSG
ERXIT	POP	D	;GET MSG
	MVI	C,PRINT
	CALL	BDOS
;
;EXIT, RESTORING STACK AND RETURN
;
EXIT	LHLD	STACK
	SPHL
	RET	;TO CCP
;
;
HELPFCB	DB	0,'HELP       ',0,0,0,0
	DS	16
	DB	0
;
INDXFCB	DB	0,'HELP    IDX',0,0,0,0
	DS	16
	DB	0
;
	DS	100	;STACK AREA
STACK	DS	2
BUFF	EQU	$	;HERE'S WHERE INDEX READ INTO
;
;BDOS/CBIOS EQUATES (VERSION 10)
;
RDCON	EQU	1
WRCON	EQU	2
RDRDR	EQU	3
PUNPUN	EQU	4
LISTOUT	EQU	5
DIRCON	EQU	6
GETIOBY	EQU	7
PUTIOBY	EQU	8
PRINT	EQU	9
RDCONBF	EQU	10	;A
CONST	EQU	11	;B
GETVERS	EQU	12	;C
RESETDK	EQU	13	;D
LOGIN	EQU	14	;E 0=A
OPEN	EQU	15	;F
CLOSE	EQU	16	;10
SRCHF	EQU	17	;11
SRCHN	EQU	18	;12
ERASE	EQU	19	;13
READ	EQU	20	;14
WRITE	EQU	21	;15
MAKE	EQU	22	;16
REN	EQU	23	;17
GETLGIN	EQU	24	;18
INQDISK	EQU	25	;19 0=A
SETDMA	EQU	26	;1A
INQALC	EQU	27	;1B
WRPROT	EQU	28	;1C
GETROV	EQU	29	;1D
SETATTR	EQU	30	;1E
GETPARM	EQU	31	;1F
SGUSER	EQU	32	;20
RDRAND	EQU	33	;21
WRRAND	EQU	34	;22
COMPSZ	EQU	35	;23
SETRAND	EQU	36	;24
BDOS	EQU	5
FCB	EQU	5CH 
FCB2	EQU	6CH
EXT	EQU	12
RNO	EQU	32
