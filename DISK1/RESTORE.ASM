;07/19/81 22:39:16
;RESTORE.ASM - TO RESTORE ("UN-KILL") CBBS MSGS,
;(PROVIDING THE SUMMARY HASN'T BEEN "PURGED")
;
;11/17/80 BY WARD CHRISTENSEN
;
;PART OF CBBS(R)
;
;FORMAT:
;	RESTORE NNNN
;RUN THIS PROGRAM FROM ANY DISK.  IT WILL TRY TO FIND
;THE KILLED FILE, MESSAGE FILE, AND NEXT FILE ON A:, AND
;WILL TRY B: IF ANY ARE NOT FOUND.
;
;
;	L-O-G-I-C  F-L-O-W
;	==================
;
;	1.	VALIDATE THE MSG #
;	2.	READ IN THE ENTIRE MESSAGE FILE
;	3.	READ THE KILLED, APPENDING THE
;		SELECTED MESSAGE TO THE MSG FILE IN MEMORY
;	4.	ERASE THE MESSAGE FILE
;	5.	WRITE BACK THE MESSAGE FILE, IN MSG # ORDER
;	6.	READ IN THE "NEXT." FILE.
;	7.	UPDATE THE # OF ACTIVE MSGS, WRITE IT BACK.
;	8.	SCAN THE SUMMARY FILE, UN-X THE MSG.
;	----------------
;
CR	EQU	0DH
LF	EQU	0AH
EOF	EQU	1AH
;
FILEDIV	EQU	2	;<==== MUST MATCH CBBS AND BUILDSUM
;
;(FROM EQU10.LIB...)
;
MF	SET	0	;SHOW MOVE NOT REQUESTED
CF	SET	0	;SHOW COMP NOT REQUESTED
;
;DEFINE SOME MACROS TO MAKE THINGS EASIER
;
;DEFINE DATA MOVE MACRO: MOVE from,to,length
;	from may be addr, or quoted string
;
MOVE	MACRO	?F,?T,?L
	MCSUB	?F,?T,?L ;;HANDLE ARGS
	CALL	MOVER
MF	SET	-1	;;SHOW EXPANSION
	ENDM
;
;COMPARE MACRO
COMP	MACRO	?F,?T,?L
	MCSUB	?F,?T,?L ;;HANDLE ARGS
	CALL	COMPR
CF	SET	-1	;;SHOW EXPANSION
	ENDM
;
;MCSUB - HANDLES MOVE, COMPARE ARGUMENTS
MCSUB	MACRO	?F,?T,?L
	IF	NOT NUL ?F
	IRPC	?C,?F
?Q	SET	'&?C&?C' ;;TEST FOR QUOTE
	EXITM
	ENDM
	IF	?Q EQ ''''
	LOCAL	?B,?Z
	CALL	?Z
?B	DB	?F
?Z	POP	H	;GET FROM
	LXI	B,?Z-?B	;GET LEN
	ELSE
	LXI	H,?F
	ENDIF
	ENDIF
	IF	NOT NUL ?T
	LXI	D,?T
	ENDIF
	IF	NOT NUL ?L
	LXI	B,?L
	ENDIF
	ENDM
;
;DEFINE CP/M MACRO - CPM FNC,PARM [,N]
;	THE THIRD PARM IS ANYTHING NON-BLANK
;	TO SUPPRESS REGISTER SAVES
;	EX:	CPM	OPEN,FCB,NOSAVE
;		CPM	OPEN,FCB,N
;
CPM	MACRO	?F,?P,?N
	IF	NUL ?N
	PUSH	B
	PUSH	D
	PUSH	H
	ENDIF
	IF	NOT NUL ?F
	MVI	C,?F
	ENDIF
	IF	NOT NUL ?P
	LXI	D,?P
	ENDIF
	CALL	BDOS
	IF	NUL ?N
	POP	H
	POP	D
	POP	B
	ENDIF
	ENDM
;
RDB	MACRO	?F,?N
	IF	NUL ?N
	PUSH	B
	PUSH	D
	PUSH	H
	ENDIF
	LXI	H,?F
	CALL	RDBYTE
	IF	NUL ?N
	POP	H
	POP	D
	POP	B
	ENDIF
	ENDM
;
WRB	MACRO	?F,?N
	IF	NUL ?N
	PUSH	B
	PUSH	D
	PUSH	H
	ENDIF
	LXI	H,?F
	CALL	WRBYTE
	IF	NUL ?N
	POP	H
	POP	D
	POP	B
	ENDIF
	ENDM
;
;EFCBGEN BUFFER PTR, # PAGES, FCB ADDR
;
EFCBGEN	MACRO	?B,?P,?F
	DW	?B
	DW	0
	DB	?P
	DW	?F
	ENDM
;
	ORG	100H
	CALL	START
	DB	'RESTORE.COM, 11/17/80'
	DB	CR,LF,'$'
START	POP	D	;GET ID
	MVI	C,PRINT
	CALL	BDOS	;PRINT ID
;
;INIT LOCAL STACK
;
	LXI	SP,STACK ;DOES JMP 0
;
;START OF PROGRAM EXECUTION
;
	CALL	INIT	;GET THINGS ROLLING
NEXTM	CALL	GETMNO	;GET MSG #
	CALL	READMF	;READ MESSAGE FILE
	CALL	APPEND	;APPEND THE KILLED
	CALL	WRMSG	;WRITE BACK THE MSG
	CALL	UPNEXT	;UPDATE NEXT FILE
	CALL	RESTSUM	;RESTORE SUMMARY FILE
	JMP	NEXTM
;
;====>	INIT	SAVES COMMAND BUFFER
;
INIT	MOVE	80H,CMDBUF,80H
	LXI	H,CMDBUF+1
	SHLD	NAMEPTR
	LDA	80H	;NO COMMAND?
	ORA	A
	JZ	NOMSG
	RET
;
;====>	GETMNO VALIDATES THE MSG #, MOVES IT TO MSGNO
;
GETMNO	MOVE	'00000',MSGNO
	LHLD	NAMEPTR
	MOV	A,M	;MSG # SPECIFIED?
	ORA	A	;WAS THAT THE LAST NAME?
	JZ	DONE
FINDSP	INX	H
	MOV	A,M
	ORA	A
	JZ	FOUND0
	CPI	' '
	JNZ	FINDSP	;LOOP UNTIL AT END
FOUND0	SHLD	NAMEPTR	;SET FOR NEXT
	DCX	H	;TO LOW DIGIT
	LXI	D,MSGNO+4 ;TO LOW DIGIT
MOVEMN	MOV	A,M	;GET CHAR
	CPI	' '
	RZ		;SET UP
	STAX	D	;STORE
	CPI	'0'
	JC	NOMSG
	CPI	'9'+1
	JNC	NOMSG
	DCX	H
	DCX	D
	MOV	A,L
	CPI	FCB AND 0FFH ;MOVED HI DIGIT?
	JNZ	MOVEMN
	RET
;
DONE	CALL	MSGEXIT	;DONE, EXIT W/MSG:
	DB	'++DONE++$'
;
;====>	READMF	READ THE MESSAGE FILE
;
READMF	CPM	WRCON,'M',N ;PROCESSING MSG
	CALL	SETMSGN	;SET UP MSG NAME
	MOVE	MSGNAME,FCB,12
	XRA	A	;INIT
	STA	FCBEXT	;	FCB
	STA	FCBRNO
	CPM	OPEN,FCB,N
	INR	A
	JNZ	MOPENOK
	MVI	A,2	;TRY B:
	STA	MSGNAME
	STA	FCB
	CPM	OPEN,FCB,N
	INR	A
	JNZ	MOPENOK
	CALL	ERXIT
	DB	'++CAN''T FIND MSG DISK, '
	DB	'NEITHER A: NOR B:++$'
;
;MSG FILE OPENED OK
;
MOPENOK	LXI	H,BUFF	;TO MSG BUFFER
MFRDLP	RDB	EFCB	;GET A BYTE
	MOV	M,A
	CPI	EOF
	JZ	MFRDN
	INX	H
	LDA	BDOS+2
	DCR	A
	CMP	H	;FULL?
	JNZ	MFRDLP
NOFIT	CALL	ERXIT
	DB	'++MSG FILE WON''T FIT IN MEMORY++$'
;
;MSG FILE READ INTO MEMORY
;
MFRDN	SHLD	MFEND	;SAVE END POINTER
	RET
;
NOMSG	CALL	ERXIT
	DB	'++MISSING OR INVALID MSG # SPECIFIED++'
	DB	CR,LF
	DB	'++PROPER FORMAT: RESTORE nnnn',CR,LF
	DB	'++or RESTORE nnnn mmmm ...$'
;
;====>	APPEND	THE KILLED MSG TO THE MSG FILE
;
APPEND	CPM	WRCON,'K',N
	MOVE	KNAME,FCB,12 ;SET UP NAME
	XRA	A
	STA	FCBEXT
	STA	FCBRNO
	CPM	OPEN,FCB,N
	INR	A
	JNZ	KOPENOK
	MVI	A,2	;TRY B:
	STA	KNAME
	STA	FCB
APTRY	CPM	OPEN,FCB,N
	INR	A
	JNZ	KOPENOK
;
;CBBS/CHICAGO PUTS THE KILLED ON C:.  TRY IT
;	ONLY IF THERE IS A C: LOGGED IN.
;
	CPM	INQLOG	;SEE IF THERE IS A 
	ANI	4	;	C: DISK
	JZ	APPNOC	;NOT LOGGED IN, IF THERE IS.
	MVI	A,3	;TRY DRIVE C:
	STA	FCB
	LXI	H,KNAME
	MOV	A,M
	MVI	M,3	;SET TO C:
	CPI	3	;ALREADY TRIED C?
	JNZ	APTRY
;
APPNOC	CALL	ERXIT
	DB	0DH,0AH
	DB	'++CAN''T FIND KILLED FILE, '
	DB	'ON EITHER A: NOR B:,',0DH,0AH
	DB	'IF THERE IS A C: DISK, IT IS '
	DB	'NOT LOGGED IN)++$'
;
;KILLED FILE OPENED OK.  FIND MSG
;
KOPENOK	LXI	H,0
	SHLD	EFCB+2	;CLEAR POINTERS
	JMP	KBRACK	;START AT "]"
KFIND	RDB	EFCB,N
	CPI	EOF
	JZ	NOTF
	CPI	LF	;START OF A LINE?
	JNZ	KFIND
KBRACK	RDB	EFCB,N
	CPI	EOF
	JZ	NOTF
	CPI	']'
	JNZ	KFIND
SKIPL	RDB	EFCB,N
	CPI	EOF
	JZ	NOTF
	CPI	LF	;END OF LINE?
	JNZ	SKIPL
	LXI	H,MSGNO	;FOR MATCH
MATCH	RDB	EFCB
	CPI	EOF
	JZ	NOTF
	CMP	M
	INX	H
	JZ	MATCH
	CPI	','	;GOOD?
	JNZ	KFIND	;NO, CONTINUE
;
;FOUND THE MESSAGE, READ IT IN
;
	LHLD	MFEND	;GET END POINTER
	MVI	M,7	;STORE BELL HDR
	INX	H	;TO NEXT
	XCHG		;SET UP FOR MOVE
	MOVE	MSGNO,,5 ;MOVE IT
	XCHG		;BACK TO HL
	MVI	M,','	;STORE TRAILING COMMA
	INX	H
	RDB	EFCB	;GET DIGIT OF MSG #
	STA	TENS
	MOV	M,A
	INX	H
RDMSG	LDA	BDOS+2
	DCR	A
	CMP	H	;FULL?
	JZ	NOFIT	;WON'T FIT
	RDB	EFCB
	MOV	M,A
	INX	H
	CPI	EOF
	JZ	RDEOF
	CPI	LF	;NEW LINE?
	JNZ	RDMSG
	RDB	EFCB	;GET NEXT LINE
	MOV	M,A
	CPI	EOF
	JZ	RDEOF
	CPI	']'	;NEXT HDR?
	INX	H	;SKIP ']'
	JNZ	RDMSG
	DCX	H	;BACK OUT ']'
;
;EOF OR END OF MSG
;
RDEOF	MVI	M,1AH	;MAKE SURE VALID EOF
	RET
;
;KILLED MSG NOT FOUND
;
NOTF	CALL	ERXIT
	DB	'++KILLED MSG NOT FOUND IN KILLED FILE++$'
;
;====>	WRMSG	WRITE BACK THE MESSAGE FILE
;
WRMSG	MOVE	MSGNAME,FCB,12
	XRA	A	;INIT
	STA	FCBRNO	;	FCB
	STA	FCBEXT
	CPM	ERASE,FCB ;ERASE THE MSG FILE
	CPM	MAKE,FCB
	INR	A
	JZ	FATAL
	LXI	H,0	;INIT
	SHLD	EFCB+2	;	EFCB
WRNXT	CALL	FINDLOW	;GET LOW MSG #
	JC	WREOF	;NO MORE, END
WRLP	MOV	A,M	;GET A CHAR
	WRB	EFCB
	MVI	M,0	;SHOW WRITTEN
	INX	H
	MOV	A,M
	CPI	EOF
	JZ	WRNXT	;	YES, TO NEXT
	CPI	7	;BELL HDR?
	JZ	WRNXT	;	YES, TO NEXT
	ORA	A	;NEXT MSG?
	JZ	WRNXT
	JMP	WRLP
;
;FILE WRITTEN, FLUSH BUFFER
;
WREOF	MVI	A,EOF
	WRB	EFCB
	LXI	H,EFCB
	CALL	FLUSH
	RET
;
FATAL	CALL	ERXIT
	DB	'++FATAL ERROR: MSG FILE ERASED, BUT '
	DB	'COULDN''T RE-MAKE IT++$'
;
;FINDLOW: RETURNS THE ADDRESS OF THE LOWEST MESSAGE
;	# IN THE BUFFER, OR CARRY IF NO MORE
;
FINDLOW	MOVE	'99999',LOWMSG ;INIT FOR COMP
	LXI	H,BUFF
FINDNXT	CALL	FINDMSG	;FIND ONE
	JC	RETLOW	;RETURN THE LOWEST
	PUSH	H	;SAVE POINTER TO IT
	INX	H	;TO MSG #
	XCHG		;TO DE
	COMP	LOWMSG,,5 ;NEW LOW ONE?
	JC	NEWLOW	;NEW LOW MSG
	POP	H
	INX	H
	JMP	FINDNXT	;FIND NEXT ONE
;
;FOUND NEW LOW MSG
;
NEWLOW	POP	H	;GET POINTER
	SHLD	LOMSGAD	;SAVE LOW MSG PTR
	INX	H	;SKIP HDR
	PUSH	H	;SAVE FOR NEXT SCAN
	MOVE	,LOWMSG,5 ;SAVE NEW LOW
	POP	H
	JMP	FINDNXT
;
;RETURN THE LOWEST MSG, CARRY IF NONE
;
RETLOW	COMP	'99999',LOWMSG
	STC
	RZ		;NO LOW MSG
	LHLD	LOMSGAD	;GET ADDR
	ORA	A
	RET
;
;FIND NEXT MSG HDR
;
FINDMSG	MOV	A,M
	CPI	7	;BELL HDR?
	RZ		;YES, RET
	CPI	EOF
	INX	H
	JNZ	FINDMSG
	STC
	RET
;
;====>	UPNEXT	UPDATE THE "NEXT" FILE
;
UPNEXT	CPM	WRCON,'N',N
	MOVE	NXTNAME,FCB,12
	XRA	A
	STA	FCBRNO
	STA	FCBEXT
	CPM	STDMA,80H,N
	CPM	OPEN,FCB,N
	INR	A
	JNZ	GOTNEXT
	MVI	A,2	;TRY DISK B:
	STA	FCB
	STA	NXTNAME
	CPM	OPEN,FCB,N
	INR	A
	JZ	NONEXT
GOTNEXT	CPM	READ,FCB,N	;READ THE SECTOR
	ORA	A
	JNZ	NEXTIOE	;I/O ERROR
	LXI	H,92H	;POINT TO LOW DIGIT
ADD1	MOV	A,M	;GET DIGIT
	ORI	'0'	;MAKE PRINTABLE
	INR	A
	MOV	M,A	;SAVE BACK
	CPI	'9'+1	;CARRY?
	JNZ	WRNBK	;NO, WRITE IT BACK
	MVI	M,'0'
	DCX	H
	JMP	ADD1
;
WRNBK	XRA	A
	STA	FCBRNO	;BACK TO FIRST REC
	CPM	WRITE,FCB,N
	ORA	A
	JNZ	NEXTIOE	;I/O ERROR
	CPM	CLOSE,FCB,N
	INR	A
	RNZ		;A-OK
	CALL	ERXIT
	DB	'++ERROR CLOSING "NEXT" FILE++$'
;
NONEXT	CALL	ERXIT
	DB	'++CAN''T FIND "NEXT" FILE TO UPDATE IT++$'
;
NEXTIOE	CALL	ERXIT
	DB	'++I/O ERROR READING "NEXT" FILE++$'
;
;====>	RESTSUM	RESTORE THE FLAG-DELETED SUMMARY
;
RESTSUM	CPM	WRCON,'S',N
	CALL	BINSRCH	;POSITION TO SECTOR
	JNC	RESTLP	;OK
	CALL	ERXIT
	DB	'++SUMMARY FILE NOT ON A: OR B:++$'
;
RESTLP	CALL	BINCOMP	;DO EXACT MATCH
	JZ	RESTIT
	JC	RESTLP	;NOT THERE YET
RESTNF	CALL	ERXIT
	DB	'++MSG NOT FOUND IN SUMMARY++',CR,LF
	DB	'++OR NOT "X"ED++$'
;
RESTIT	CALL	URDBYTE	;READ THE COMMA
	CPI	','
	JNZ	RESTNF
	CALL	URDBYTE	;GET #
	CPI	'X'
	JNZ	RESTNF
	CALL	UNRDBYT	;BACK IT OUT
	LDA	TENS	;RESTORE 10S DIGIT
	LXI	H,FCBRNO ;POINT TO REC #
	DCR	M	;BACK UP FOR WRITE
	CALL	UWRBYTE	;UNBUFFERED WRITE
;
;JUST IN CASE "UWRBYTE" WROTE THE 128TH
;BYTE, IT ALSO DID THE PHYSICAL WRITE.
;
	LDA	BUFPTR
	CPI	80H
	JZ	SUMCLOS	;YEP, ALREADY WRITTEN
	CPM	WRITE,FCB,N
	ORA	A	;WRITE OK?
	JNZ	SWCERR
SUMCLOS	CPM	CLOSE,FCB,N
	INR	A
	RNZ
SWCERR	CALL	ERXIT
	DB	'++SUMMARY WRITE OR CLOSE ERROR++$'
;
;====>	BINSRCH - ROUTINE TO DO A 6 LEVEL BINARY
;SEARCH OF THE SUMMARY.
;
BINSRCH	MOVE	SUMNAME,FCB,12
	XRA	A
	STA	FCBEXT
	CPM	STDMA,80H,N
	CPM	OPEN,FCB,N
	INR	A
	JNZ	SUMFD	;FOUND
	MVI	A,2	;TRY DRIVE B:
	STA	FCB
	STA	SUMNAME
	CPM	OPEN,FCB,N
	INR	A
	STC		;ERROR INDICATOR
	RZ		;NO SUMMARY
;
;SEE IF 80H RECORDS, IF SO, MIGHT BE SECOND EXTENT
;
SUMFD	LDA	FCBNSEC	;GET # SECTORS
	CPI	80H	;FULL EXTENT
	JNZ	BINGO	;GO WITH FIRST EXTENT
;
;IF THERE IS AN EOF IN THIS SECTOR, FORGET 
;SECOND EXTENT.  IF NO EOF, FIND THE HIGHEST
;MSG # IN THIS EXTENT BY SCANNING FOR THE
;L-A-S-T BELL HEADER IN THE SECTOR
;
	MVI	A,7FH
	STA	FCBRNO	;REC # TO READ
	STA	LOSECT	;USED BY "BINGOT"
	CALL	BUF100
	CALL	URDBYTE	;FORCE SECTOR READ
	LXI	H,80H
BINCKE	MOV	A,M
	CPI	EOF
	JZ	BINGO	;GO WITH 1ST EXTENT
	CPI	7	;BELL?
	JNZ	BINNB	;NO
	MOV	D,H
	MOV	E,L	;COPY PTR TO DE
BINNB	INR	L	;DONE?
	JNZ	BINCKE
;DE HAS POINTER TO LAST BELL HDR
	XCHG		;TO HL
	SHLD	BUFPTR	;SETUP FOR READ
	CALL	BINCOMP	;READ, COMPARE
;MAKE SURE WE DIDN'T GO INTO NEXT EXTENT
	PUSH	PSW	;SAVE BINCOMP RESULT
	LDA	FCBEXT
	ORA	A
	JZ	BINE1	;STILL IN EXT 1
	XRA	A
	STA	FCBEXT
	CPM	OPEN,FCB
	INR	A
	JNZ	BINE1
NOSUM	CALL	ERXIT
	DB	'++SUMMARY OPEN ERROR++$'
;
BINE1	POP	PSW	;RESTORE RESULT
	JZ	BINGOT	;EXACT HIT
	JC	BINEXT	;TO NEXT EXTENT
;
;POSITIONED TO RIGHT EXTENT - START READING.
;
BINGO	XRA	A	;0..
	STA	LOSECT	;..TO LOW
	LDA	FCBNSEC	;MAX #..
	STA	HISECT	;..TO HI
	MVI	A,6	;SET SEARCH..
	STA	SRCHLVL	;..LEVEL
;
BINMID	LDA	LOSECT	;MIDDLE..
	LXI	H,HISECT ;..= LOW
	ADD	M	;..+ HI..
	RAR		;..DIVIDED BY 2
	STA	MIDSECT
	STA	FCBRNO
	CALL	BUF100	;FORCE READ
	CALL	BINCOMP	;COMPARE MSG FOUND
	JC	BINHI	;GO HIGHER
	JNZ	BINLOW	;LOWER OR EOF
;GOT THE EXACT MESSAGE
	LDA	MIDSECT
	STA	LOSECT
	JMP	BINGOT
;
;GO LOWER
;
BINLOW	XRA	A	;ZAP OFF..
	STA	EOFLG	;..EOF COND.
	LDA	MIDSECT
	STA	HISECT
	JMP	BINCK	;SEARCH DONE?
;
;GO HIGHER
;
BINHI	LDA	MIDSECT
	STA	LOSECT
BINCK	LXI	H,SRCHLVL
	DCR	M
	JNZ	BINMID	;LOOP TILL 'N' LEVELS
;
;DONE WITH SEARCH, GO FROM HERE
;
BINGOT	LDA	LOSECT	;START AT LOW
	STA	FCBRNO
	CALL	BUF100	;INIT FOR READ
;
;SCAN TO NEXT BELL HEADER TO GET READY
;
BINBELL	CALL	URDBYTE
	CPI	EOF
	JZ	BINBACK
	CPI	7
	JNZ	BINBELL
BINBACK	CALL	UNRDBYT	;BACK UP
	RET
;
;
;---->	BINCOMP - SCAN SUMMARY FOR MSG HDR.
;CARRY:	FOUND LOWER MSG #
;ZERO:	FOUND = MSG #, OR EOF
;NOT 0:	FOUND HIGHER MSG #
;
BINCOMP	CALL	URDBYTE
	CPI	EOF
	JZ	BINCEOF	;GO LOWER
	CPI	7	;BELL HDR?
	JNZ	BINCOMP
	LXI	H,MSGNO	;GOT BELL,..
	MVI	B,5	;..MATCH MSG
BINSRM	CALL	URDBYTE
	CPI	EOF	;INVALID EOF
 	JZ	BINCEOF
	CMP	M
	INX	H
	RC		;GO HIGHER
	RNZ		;LOWER
	DCR	B	;=, CONTINUE
	JNZ	BINSRM
	RET		;GOT THE EXACT MESSAGE
;
;GOT EOF
;
BINCEOF	ORA	A	;RESET CARRY, NOT ZERO
	RET
;
;GO TO NEXT EXTENT
;
BINEXT	MVI	A,1
	STA	FCBEXT
	CPM	OPEN,FCB,N
	INR	A
	JZ	NOSUM	;ERROR
	XRA	A
	STA	FCBRNO	;START AT BEGINNING
	JMP	BINGO	;GO WITH 2ND EXT.
;
BUF100	LXI	H,100H
	SHLD	BUFPTR	;FORCE READ
	RET
;
;====>	UNBUFFERED READ/WRITE ROUTINES
;
URDBYTE	LDA	EOFLG
	CPI	EOF
	RZ
	PUSH	H
	LHLD	BUFPTR
	MOV	A,H
	ORA	A
	JZ	URNORD	;NO READ REQ'D
	CPM	READ,FCB
	ORA	A
	LXI	H,80H
	JZ	URNORD	;READ OK?
	MVI	A,1AH	;NO, CALL IT EOF
	STA	EOFLG	;SET FOR NEXT TIME
	POP	H	;RESTORE
	RET		;RETURN
;
URNORD	MOV	A,M
	INX	H
	SHLD	BUFPTR
	POP	H
	RET
;
;UN-READ A BYTE MAY BE ONLY CALLED ONCE,
;SINC IT MIGHT OTHRWISE BACK OVER A SECTOR
;
UNRDBYT	PUSH	H
	LHLD	BUFPTR
	DCX	H
	SHLD	BUFPTR
	POP	H
	RET
;
UWRBYTE	PUSH	H
	LHLD	BUFPTR
	MOV	M,A
	INX	H
	MOV	A,H
	ORA	A
	JZ	UWNOWR	;NO READ REQ'D
	CPM	WRITE,FCB
	ORA	A
	JNZ	UWRERR
	LXI	H,80H
UWNOWR	SHLD	BUFPTR
	POP	H
	RET
;
UWRERR	CALL	ERXIT
	DB	'++SUMMARY WRITE ERROR++$'
;
;====>	SETMSGN	SET MESSAGE NUMBER.
;
;IN BASIC, THIS WOULD SIMPLY BE:
;FILE# = FILEDIV*INT(MSGNO/FILEDIV) 
;
;1. CONVERT LAST 2 DIGITS OF MSGNO TO BINARY
SETMSGN	LXI	H,MSGNO+3 ;TO ASCII #
	MOV	A,M	;GET 10S
	SUI	'0'	;MAKE BINARY
	MOV	B,A
	ADD	A	;X2
	ADD	A	;X4
	ADD	B	;X5
	ADD	A	;X10
	INX	H	;TO UNITS
	ADD	M	;ADD UNITS
	SUI	'0'	;BACK OUT ASCII BIAS
;2. DIVIDE BY FILEDIV
	MVI	B,0FFH	;QUOTIENT
	MVI	C,FILEDIV ;DIVISOR
SETMDIV	INR	B
	SUB	C	;SUBTRACT DIVISOR
	JNC	SETMDIV	;LOOP 'TILL DONE
;3. MULTIPLY BY FILEDIV
	MVI	C,FILEDIV
	XRA	A
SETMMUL	ADD	B
	DCR	C
	JNZ	SETMMUL
;4. CONVERT BACK TO ASCII IN MSGFT
	LXI	H,MSGNAME+10
	MVI	M,'0'-1
SETM2	INR	M
	SUI	10
	JNC	SETM2
	ADI	10+'0'
	INX	H
	MOV	M,A
	RET		;WITH MSGNAME SET.
;
;FOLLOWING FROM 'EQU10.LIB'---->
;
;MOVE, COMPARE SUBROUTINES
;
	IF	MF	;MACRO EXPANSION FLAG SET?
MOVER	MOV	A,M
	STAX	D
	INX	H
	INX	D
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	MOVER
	RET
	ENDIF
;
	IF	CF	;MACRO EXPANSION FLAG SET?
COMPR	LDAX	D
	CMP	M
	RNZ
	INX	D
	INX	H
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	COMPR
	RET
	ENDIF
;
;	FROM EQU10.LIB: AS OF 07/19/80
;
;RDBYTE, HL POINTS TO EXTENDED FCB:
;
;	2 BYTE BUFFER ADDR
;	2 BYTE "BYTES LEFT" (INIT TO 0)
;	1 BYTE BUFFER SIZE (IN PAGES)
;	2 BYTE FCB ADDRESS
;
RDBYTE	MOV	E,M
	INX	H
	MOV	D,M	;GET BUFFER ADDR
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M	;BC = BYTES LEFT
	MOV	A,B	;GET COUNT
	ORA	C
	JNZ	RDBNORD	;NO READ
;
	INX	H	;TO BUFFER SIZE
	MOV	A,M	;GET COUNT
	ADD	A	;MULTIPLY BY 2
	MOV	B,A	;SECTOR COUNT IN B
	INX	H	;TO FCB
	PUSH	H	;SAVE FCB POINTER
	MOV	A,M	;GET..
	INX	H	;..FCB..
	MOV	H,M	;..ADDR..
	MOV	L,A	;..TO HL
;
RDBLP	MVI	A,1AH	;GET EOF CHAR
	STAX	D	;SAVE IN CASE EOF
	PUSH	D	;SAVE DMA ADDR
	PUSH	H	;SAVE FCB ADDR
	CPM	STDMA	;SET DMA ADDR
	POP	D	;GET FCB
	CPM	READ
	ORA	A
	POP	H	;HL=DMA, DE=FCB
	JNZ	RDBRET	;GOT EOF
	MOV	A,L
	ADI	80H	;TO NEXT BUFF
	MOV	L,A
	MOV	A,H
	ACI	0
	MOV	H,A
	XCHG		;DMA TO DE, FCB TO HL
	DCR	B	;MORE SECTORS?
	JNZ	RDBLP	;YES, MORE
RDBRET	POP	H	;GET FCB POINTER
	DCX	H	;TO LENGTH
	MOV	A,M	;GET LENGTH
	DCX	H	;TO COUNT
	MOV	M,A	;SET PAGE COUNT
	DCX	H	;TO LO COUNT
	DCX	H	;TO HI FCB
	DCX	H	;TO EFCB START
	JMP	RDBYTE	;LOOP THRU AGAIN
;
RDBNORD	INX	H	;TO LENGTH
	MOV	A,M	;GET LENGTH (PAGES)
	XCHG		;BUFF TO HL
	ADD	H
	MOV	H,A	;HL = END OF BUFF
	MOV	A,L
	SUB	C
	MOV	L,A
	MOV	A,H
	SBB	B
	MOV	H,A	;HL = DATA POINTER
	MOV	A,M	;GET BYTE
	XCHG		;EFCB BACK TO HL
	CPI	1AH	;EOF?
	RZ		;YES, LEAVE POINTERS
	DCX	B	;DECR COUNT
	DCX	H	;BACK TO "BYTES LEFT"
	MOV	M,B
	DCX	H
	MOV	M,C	;STORE BACK COUNT
	RET
;
;SAMPLE EFCB:
;
;EFCB	DW	BUFF	;BUFFER ADDR
;	DW	0	;BYTES LEFT (OR TO WRITE)
;	DB	20	;BUFFER SIZE (IN PAGES)
;	DW	FCB	;FCB ADDRESS
;
;..OR VIA EFCBGEN MACRO:
;
;MYEF	EFCBGEN	BUFF,20,FCB
;
;WRBYTE, HL POINTS TO EXTENDED FCB:
;
;	2 BYTE BUFFER ADDR
;	2 BYTE "BYTES LEFT" (INIT TO 0)
;	1 BYTE BUFFER SIZE (IN PAGES)
;	2 BYTE FCB ADDRESS
;
WRBYTE	MOV	E,M
	INX	H
	MOV	D,M	;DE=BUF ADDR
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M	;BC=BYTES IN BUFF
	PUSH	D	;SAVE FCB
	XCHG
	DAD	B	;TO NEXT BYTE
	MOV	M,A	;STORE IT
	INX	B	;ONE MORE
	XCHG
	POP	D
;
;SEE IF BUFFER IS FULL
;
	INX	H	;GET
	MOV	A,M	;	SIZE
	CMP	B	;FULL?
	JNZ	WRBNOWR	;NO WRITE
;
	ADD	A	;MULTIPLY BY 2
	MOV	B,A	;SECTOR COUNT IN B
	INX	H	;TO FCB
	PUSH	H	;SAVE FCB POINTER
	MOV	A,M	;GET..
	INX	H	;..FCB..
	MOV	H,M	;..ADDR..
	MOV	L,A	;..TO HL
;
WRBLP	PUSH	D	;SAVE DMA ADDR
	PUSH	H	;SAVE FCB ADDR
	CPM	STDMA	;SET DMA ADDR
	POP	D	;GET FCB
	CPM	WRITE
	ORA	A
	POP	H	;HL=DMA, DE=FCB
	JNZ	WRBERR	;GOT ERR
	MOV	A,L
	ADI	80H	;TO NEXT BUFF
	MOV	L,A
	MOV	A,H
	ACI	0
	MOV	H,A
	XCHG		;DMA TO DE, FCB TO HL
	DCR	B	;MORE SECTORS?
	JNZ	WRBLP	;YES, MORE
WRBRET	POP	H	;GET FCB POINTER
	DCX	H	;TO LENGTH
	DCX	H	;TO COUNT
	MVI	M,0	;SET 0 TO WRITE
	DCX	H	;TO LO COUNT
	MVI	M,0
	CPM	STDMA,80H
	RET
;
WRBERR	CALL	ERXIT
	DB	'++ERROR IN WRBYTE ROUTINE++$'
;
WRBNOWR	DCX	H	;TO LENGTH
	MOV	M,B	;SET NEW LENGTH
	DCX	H
	MOV	M,C
	RET
;
;FLUSH THE EFCB BUFFERS
;
FLUSH	MOV	E,M
	INX	H
	MOV	D,M	;DE=BUF ADDR
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M	;BC=BYTES IN BUFF
	INX	H	;TO COUNT
	MOV	A,B
	ORA	C
	RZ		;NOTHING TO WRITE
	MOV	A,C	;GET LOW COUNT
	ADD	A	;SHIFT "128" TO CARRY
	MOV	A,B	;GET HI COUNT
	RAL		;X2, ADD IN CARRY
	INR	A	;ALLOW FOR PARTIAL
	MOV	B,A	;B=# SECTORS TO WRITE
	INX	H	;TO FCB
	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A	;HL=FCB
FLUSHL	CPM	STDMA
	XCHG
	CPM	WRITE
	XCHG
	ORA	A
	JNZ	WRBERR
	PUSH	H
	LXI	H,80H
	DAD	D
	XCHG
	POP	H
	DCR	B
	JNZ	FLUSHL
	XCHG
	CPM	CLOSE
	INR	A
	RNZ
	CALL	ERXIT
	DB	'++OUTPUT FILE CLOSE ERROR ++$'
;
;EXIT WITH ERROR MESSAGE
;
MSGEXIT	EQU	$	;EXIT W/"INFORMATIONAL" MSG
ERXIT	POP	D	;GET MSG
	MVI	C,PRINT
	CALL	BDOS
;
;EXIT, RESTORING STACK AND RETURN
;
EXIT	CPM	STDMA,80H
	JMP	0
;
EFCB	EFCBGEN	DBUFF,4,FCB
MSGNO	DB	'00000*' ;* TO FORCE MISMATCH AFTER 5
KNAME	DB	1,'KILLED     '
NXTNAME	DB	1,'NEXT       '
SUMNAME	DB	1,'SUMMARY    '
MSGNAME	DB	1,'MESSAGE XXX'
EOFLG	DB	0	;NOT EOF ON UNBUFFERED READ
;	---------------- DB'S ABOVE, DS'S BELOW
LOSECT	DS	1
MIDSECT	DS	1
HISECT	DS	1
SRCHLVL	DS	1
LOWMSG	DS	5	;FOR COMPARE TO FIND LOWEST
LOMSGAD	DS	2	;POINTER TO LO MSG
TENS	DS	1	;THE 10'S DIGIT X'D IN SUMMARY
	DS	100	;STACK AREA
STACK	DS	2
MFEND	DS	2	;MSG FILE END PTR
DBUFF	DS	4*256	;DISK BUFFER
BUFPTR	DS	2	;UNBUFFERED R/W PTR
NAMEPTR	DS	2	;POINTER TO FOLLOWING:
CMDBUF	DS	128	;COPIED FROM 80H
BUFF	EQU	$
;
;
;BDOS/CBIOS EQUATES (VERSION 10) (UNUSED: DELETED)
;
WRCON	EQU	2
PRINT	EQU	9
CONST	EQU	11
OPEN	EQU	15
CLOSE	EQU	16
ERASE	EQU	19
READ	EQU	20
WRITE	EQU	21
MAKE	EQU	22
INQLOG	EQU	24
STDMA	EQU	26
BDOS	EQU	5
FCB	EQU	5CH 
FCB2	EQU	6CH
FCBEXT	EQU	FCB+12
FCBNSEC	EQU	FCB+15
FCBRNO	EQU	FCB+32
