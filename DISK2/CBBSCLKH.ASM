;CBBS V3.6.2 	CBBSCLKH.ASM - D.C. HAYES CLOCK FUNCTIONS 05/23/82 HLB
;09/23/83
; LINKED FROM CBBSDISK ONLY IF CLOCKH=TRUE
;
;	LINKS TO CBBSSUB1
;
;	O O O	O	O   O	O   O	
;	O	O	O  O	O   O
; CBBS	O	O	OOO	O O O	.ASM
;	O	O	O  O	O   O
;	O O O	O O O	O   O	O   O
;
;====>	HISTORICAL COMMENTS written to various 
;	"History.xxx" files.
;
;	Note from Randy:
;	I believe this is for the 8250 uart in an H89, would
;have to be changed for other I/O boards/Uarts.
;
;	----------------
;D.C HAYES  CLOCK EQUATES
;
DCPORT	EQU	0C0H		;BASE PORT ADDRESS (300Q)
DCLPORT	EQU	DCPORT+3	;LINE CONTROL
DCSPORT	EQU	DCPORT+5	;USART STATUS PORT
DCTEMPT	EQU	20H		;XMIT BUFFER EMPTY
DCDATAV	EQU	01H		;DATA AVAILABLE
DCBRMS	EQU	000H		;MS FOR 1200 BAUD
DCBRLS	EQU	060H		;LS FOR 1200 BAUD
LCWLS0	EQU	1H
LCWLS1	EQU	2H
;
;
;
;'T' COMMAND: PRINTS DATE, TIME, ELAPSED TIME
;
PRDTIME	CALL	PRETIME
	JMP	FUNCT
;
;DATE/TIME PRINT SUBROUTINE
;
PRTIME	LXI	H,ANSWER ;STORE IT HERE
	PUSH	H
	CALL	RDDATE
	MVI	M,' '
	INX	H
	CALL	RDTIME	;GET TIME
	MVI	M,0
	POP	H
	MOV	A,M	;GET HI
	CPI	'3'	;VALID?
	JNC	CLKINO1
	CALL	TYPEM0	;TYPE DATE
	CALL	CRLF
	ORA	A	;SHOW CLOCK IS OK
	RET
;
CLKINOP	POP	H	;FIXUP STACK
CLKINO1	CALL	ILPRT
	DB	'++Clock inop++',CR,LF,0
	STC		;SHOW ERROR
	RET
;
;PRETIME: PRINTS CURRENT AND ELAPSED TIME
;
PRETIME	CALL	PRTIME
	RC		;RET IF NO CLOCK
	LXI	H,ANSWER
	PUSH	H
	CALL	RDTIME
	POP	H
	CALL	CONVTBI	;HL=BINARY CURR TIME
	PUSH	H
	LXI	H,LGINTIM ;GET LOGGED IN TIME
	CALL	CONVTBI	;HL=LOGGED IN TIME
	POP	D	;DE=CURR TIME
;SUBTRACT TO GET ELAPSED MINUTES
	MOV	A,E
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	RAL		;CARRY IF NEG
	JNC	PRETOK
;ELAPSED TIME IS NEGATIVE - ADD 24 HOURS
	LXI	D,24*60	;1 DAY OF MINUTES
	DAD	D
PRETOK	MOV	A,H
	ORA	A	;>255 MINUTES?
	JNZ	PREBAD
	MOV	A,L	;GET TIME
	CPI	120	;>2 HRS? PROB. BAD.
	JNC	PREBAD
;E.T. IS VALID, PRINT IT
	PUSH	PSW
	CALL	ILPRT
	DB	'Time on HUG-CBBS ',0
	POP	PSW
	CALL	PRDEC
	CALL	ILPRT
	DB	' minutes',CR,LF,0
	RET
;
PREBAD	CALL	ILPRT
	DB	'Unable to calc connect time',cr,lf,0
	RET
;
;WRITE DATE, TIME, ELAPSED TIME
;
WRETIME	CALL	PRETIME	;PRINT & CALC ELAPSED
	RC		;INVALID CLOCK
	LXI	H,decnum
;
;	skip over leading spaces (02/27/83 mod)
;
wretsk	mov	a,m
	inx	h
	cpi	' '
	jz	wretsk
	dcx	h
	JMP	WRVAR	;WRITE ELAPSED, ","
;
;WRITE DATE AND TIME TO CURRENTLY OPEN
;FILE (USUALLY LOG, BUT SOMETIMES "NOTES")
;
WRTIME	LXI	H,ANSWER ;WORK AREA
	PUSH	H
	CALL	RDDATE
	MVI	M,0DH
	POP	H
	RC
	MOV	A,M
	CPI	'2'	;VALIDATE
	CMC		;	THE
	RC		;	TIME
	PUSH	H
	CALL	WRVARC	;WRITE DATE
	POP	H
	PUSH	H
	CALL	RDTIME
	MVI	M,0DH
	POP	H
	JMP	WRVARC	;WRITE DATE
;
;RDTIME - STORES THE TIME "HH:MM:SS " INTO
;	FIELD POINTED TO BY HL.  UPON RETURN,
;	HL POINTS PAST LAST BYTE.
;
RDTIME	CALL	CLKINIT
	PUSH	H
	LXI	H,DCSTR		;POINT TO TIME REQUEST
	CALL	PLUG		;SEND REQUEST
	POP	H		;BUFFER TO STORE IN
	MVI	D,':'		;TIME SEPARATOR
	CALL	DCSAVIT		;COLLECT DATA FROM CLOCK
	RET
;
;RDDATE - STORES THE DATE "MM/DD/YY " INTO
;	FIELD POINTED TO BY HL.  UPON RETURN,
;	HL POINTS PAST LAST BYTE.
;
RDDATE	CALL	CLKINIT
	PUSH	H
	LXI	H,DCSTR1	;POINT TO DATE REQUEST
	CALL	PLUG		;SEND IT
	LXI	H,DCTBUFF	;SAVE DATE HERE
	MVI	D,'/'		;USE SLASH SEPARATOR
	CALL	DCSAVIT
	POP	H		;PUT REFORMATED DATA HERE
	LDA	DCTBUFF+3	;GET TENS OF MONTH
	MOV	M,A
	INX	H
	LDA	DCTBUFF+4	;GET MONTH UNITS
	MOV	M,A
	INX	H
	LDA	DCTBUFF+2	;GET SEPARATOR
	MOV	M,A
	INX	H
	LDA	DCTBUFF+6	;GET TENS OF DAY
	MOV	M,A
	INX	H
	LDA	DCTBUFF+7	;GET ONES OF DAY
	MOV	M,A
	INX	H
	LDA	DCTBUFF+5	;GET SEPARATOR
	MOV	M,A
	INX	H
	LDA	DCTBUFF		;GET TENS OF YEARS
	MOV	M,A
	INX	H
	LDA	DCTBUFF+1	;GET YEARS UNITS
	MOV	M,A
	INX	H
	RET
;
;====>	CLKINIT	INITIALIZES THE CLOCK FOR READ
;
CLKINIT	EQU	$
;
;INIT USART
;
	PUSH	H
	PUSH	D
	MVI	D,DCBRMS	;SET UP BAUD RATE
	MVI	E,DCBRLS
	MVI	A,83H		;SET DLAB
	OUT	DCLPORT
	MOV	A,E		;GET LSB FOR BAUD RATE
	OUT	DCPORT
	MOV	A,D		;GET MSB
	OUT	DCPORT+1
	MVI	A,LCWLS0+LCWLS1	;1 STOP 8 DATA BITS
	OUT	DCLPORT		;RESET DLAB
	XCHG			;PUT DIVISOR IN HL
	DAD	H
	DAD	H
	DAD	H
	DAD	H		;MULTIPLY 16 TIMES
;				FOR 2 CHAR TIMES
DCLOOP1	DCX	H
	MOV	A,L
	ORA	H
	JNZ	DCLOOP1		;LOOP 2 CHAR TIMES
	XCHG
	IN	DCPORT		;CLEAR GARBAGE
	IN	DCPORT
	POP	D
	POP	H
	RET
;
;	PLUG SENDS OUT THE TIME OR DATE REQUEST STRING TO THE CLOCK
;
;	ENTRY (HL) = STRING TO BE SENT OUT (END OF STRING IS  @)
;
;	EXIT  (HL) = END OF STRING
;
;	USES A,HL
;
PLUG	MOV	A,M		;GET CHAR
	CPI	'@'		;LOOK FOR DELIMITER
	RZ			;ALL DONE
	CALL	DCOUTCH		;SEND IT
	INX	H		;NEXT CHAR
	JMP	PLUG
DCOUTCH	PUSH	PSW
DCOUTC	IN 	DCSPORT		;GET STATUS
	ANI	DCTEMPT		;READY TO SEND?
	JZ	DCOUTC		;WAIT TILL READY
	POP	PSW
	OUT	DCPORT		;SEND CHAR
	RET
;
;DCSAVIT STORES THE TIME INFO IN MEM AND INSERTS SEPARATORS
;FOR THE TIME OR DATE. IT WILL READ 6 DIGITS PLUS THE ENDING CR
;FROM THE CLOCK
;
;	ENTRY	(HL) = BUFFER LOCATION TO STORE DATA
;		(D)  = SEPARATOR CHAR -- (:) FOR TIME  (/) FOR DATE
;
;	EXIT	(HL) = ADDRESS OF NEXT CHAR TO BE STORED
;		(D) =  UNCHANGED
;
;	USES	A,HL
;
DCSAVIT	CALL	DCINCHA		;GET 1ST CHAR
	CALL	DCSAV1		;SAVE IT
	CALL	DCINCHA		;GET 2ND CHAR
	CALL	DCSAV1		;SAVE IT
	MOV	A,D		;GET SEPARATOR
	CALL	DCSAV1
	CALL	DCINCHA		;GET 3RD DIGIT
	CALL	DCSAV1
	CALL	DCINCHA		;GET 4TH DIGIT
	CALL	DCSAV1
	MOV	A,D		;GET SEPARATOR
	CALL	DCSAV1
	CALL	DCINCHA		;GET 5TH DIGIT
	CALL	DCSAV1
	CALL	DCINCHA		;GET 6TH DIGIT
	CALL	DCSAV1
	CALL	DCINCHA		;CLEAR CR FROM CLOCK
	RET
DCSAV1	MOV	M,A		;SAVE IT
	INX	H		;POINT TO NEXT CHAR
	RET
;
DCINCHA	IN	DCSPORT		;GET STATUS
	ANI	DCDATAV		;DATA THERE?
	JZ	DCINCHA		;NO WAIT FOR IT
	IN	DCPORT		;HAVE CHAR
	ANI	7FH		;MASK PARITY
	RET			;DONE
;
;
;
DCSTR	DB	'ATRT',0DH,'@'	;TIME REQUEST STRING
DCSTR1	DB	'ATRD',0DH,'@'	;DATE REQUEST STRING
DCTBUFF	DS	10		;TEMPORY WORK BUFFER FOR DATE
;
;END OF CLOCK ROUTINES
;
;SUBROUTINE TO CONVERT ASCII TIME TO BINARY
;
;USED TO PRINT CALLER'S ELAPSED TIME
;
;	HL POINTS TO "HH:MM"
;
;	BINARY MINUTES RETURNED IN HL
;
CONVTBI	MOV	B,H	;POINTER
	MOV	C,L	;	TO BC
	LXI	H,0	;INIT ANS
	CALL	CT10F	;GET DIGIT
	CALL	CT10	;X 10 + NEXT DIGIT
	INX	B	;SKIP COLON
	CALL	CT6	;X 6 + NEXT DIGIT
;
;FALL INTO CB10, TO MULTIPLY BY 10
;AND GET LAST DIGIT
;
;MULTIPLY HL BY 10 AND ADD IN BINARY
;VALUE OF NEXT ASCII DIGIT POINTED TO BY BC.
;
CT10	MOV	D,H	;SET UP
	MOV	E,L	;	FOR MULT
	DAD	H	;X2
	DAD	H	;X4
	DAD	D	;X5
	DAD	H	;X10
;
;ENTER HERE TO GET FIRST DIGIT
;
CT10F	LDAX	B	;GET DIGIT
	INX	B	;TO NEXT DIGIT
	SUI	'0'	;MAKE BINARY
	ADD	L	;ADD TO LOW
	MOV	L,A	;SAVE BACK
	RNC
	INR	H	;ADD IN CARRY
	RET
;
;ROUTINE TO MULTIPLY HL BY 60, AND ADD
;IN NEXT DIGIT
;
CT6	MOV	D,H	;SET UP
	MOV	E,L	;	FOR MULT
	DAD	H	;X2
	DAD	D	;X3
	DAD	H	;X6
	JMP	CT10F	;GET DIGIT
;
	ENDIF		;CLOCKH
;
 	LINK	CBBSSUB1 ;TO NEXT .ASM FILE
RY WORK BUFFER FOR DATE
;
;END OF CLOCK ROUTINES
;
;SUBROUTINE TO CONVERT ASCII TIME TO BINARY
;
;USED TO PRINT CAL