;BUILDSUM VERSION 3.4,0	<- LAST DIGIT = EDIT SEQ #
;
;FORMAT:
;
;	BUILDSUM
; OR	BUILDSUM M: S:
;
;WHERE M: IS THE MESSAGE DISK, AND S: IS THE SUMMARY DISK.
;
;FOR EXAMPLE, TO BUILD SUMMARIES FROM MESSAGE DISK ON A:
;TO SUMMARY DISK ON B: DO: BUILDSUM A: B:
;
;	----------------
;	11/27/79
;ORIGINALLY WRITTEN BY WARD CHRISTENSEN
;	11/06/80
;MODIFY FOR VARIABLE # OF FILES
;
;NOTE: IF YOU SET FILEDIV TO 1 IN BUILDSUM, THEN IT WILL
;WORK NO MATTER HOW MANY MESSAGE FILES YOU HAVE -
;BECAUSE IT WILL SCAN FROM MESSAGE.X00 THRU
;MESSAGE.X99.  IT WILL ONLY WASTE A BIT OF TIME
;SCANNING THE DIRECTORY FOR NON-EXISTANT FILES. 
;
;THUS FOR BEST EFFICIENCY, SET FILEDIV THE SAME AS
;YOUR CBBS FILEDIV.  DO N-O-T GENERALIZE THAT A
;"SMALLER" FILEDIV IS OK FOR BUILDSUM: ONLY THE
;CORRECT ONE, OR 1, OR A V-E-R-Y FEW OTHER IN-
;STANCES (4 INSTEAD OF 8, BUT NOT 6 INSTEAD OF 12) WORK.
;
* * * * * * * * SET THE FOLLOWING * * * * * * * * * * *	*
;
FILEDIV	EQU	2	;100/FILEDIV = # OF MSG FILES
;
;	     FILEDIV #-FILES
;
;		1      100
;		2	50	<==== CBBS STANDARD 
;		3	34
;		4	25
;		5	20
;		6	17
;		7	15
;		8	13
;		9	12	N-O-T-E:
;		10	10	OTHER VALUES (E.G. 22)
;		12	 9	MAY BE USED, BUT WILL
;		13	 8	RESULT IN LESS EVEN
;		15	 7	DISTRIBUTION OF MESSAGE
;		17	 6	FILES.
;		20	 5
;		25	 4
;		34	 3
;		50	 2
;	       100	 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;
K	EQU	1024
;
;DON'T MAKE FOLLOWING BUFFER "TOO" BIG, AS THE SUMMARY
;MUST FIT IN MEMORY, AND MAKING BUFSZ TOO BIG MAY MEAN
;THERE ISN'T ROOM FOR THE SUMMARY
;
BUFSZ	EQU	2*K	;2K DISK READ BUFFER
;
LF	EQU	0AH
CR	EQU	0DH
EOF	EQU	1AH
;
;
;================> NOTE
;THE SUMMARY M-U-S-T FIT IN MEMORY, SO YOU MAY
;HAVE TO BUILD THE SUMMARY IN A SYSTEM OF > 32K,
;DEPENDING UPON YOUR SUMMARY SIZE.
;
	ORG	100H
	CALL	START
	DB	'BUILDSUM VERSION 3.4, 11/06/80'
	DB	0DH,0AH,'$'
START	POP	D	;GET ID
	MVI	C,PRINT
	CALL	BDOS	;PRINT ID
;
;INIT LOCAL STACK
;
	LXI	SP,STACK
;
;START OF PROGRAM EXECUTION
;
	LDA	FCB2	;GET SUMMARY DISK
	STA	SUMMARY	;SAVE IT
;
;SEE IF BUMPING MSG # RESULTS IN A DIFFERENT FILE
;
NEXTFL	LXI	H,MSGNO+2 ;TO UNITS
	CALL	ADD1	;BUMP BY 1 IN ASCII
;
;11/06/80 MODS FOR ANY # OF MSG FILES
;
;SET MESSAGE NUMBER.  IN BASIC, THIS WOULD SIMPLY BE:
;FILE# = FILEDIV*INT(MSGNO/FILEDIV) 
;
;1. CONVERT LAST 2 DIGITS OF MSGNO TO BINARY
;
SETMSGN	LXI	H,MSGNO+1 ;TO ASCII TENS
	MOV	A,M	;GET TENS
	SUI	'0'	;MAKE BINARY
	MOV	B,A
	ADD	A	;X2
	ADD	A	;X4
	ADD	B	;X5
	ADD	A	;X10
	MOV	B,A	;SAVE
	INX	H	;TO UNITS
	MOV	A,M	;GET UNITS
	SUI	'0'	;MAKE BINARY
	ADD	B	;A=DECIMAL VALUE
;2. DIVIDE BY FILEDIV
	MVI	B,0FFH	;QUOTIENT
	MVI	C,FILEDIV ;DIVISOR
SETMDIV	INR	B
	SUB	C	;SUBTRACT DIVISOR
	JNC	SETMDIV	;LOOP 'TILL DONE
;3. MULTIPLY BY FILEDIV
	MVI	C,FILEDIV
	XRA	A
SETMMUL	ADD	B
	DCR	C
	JNZ	SETMMUL
;4. CONVERT BACK TO ASCII IN MSGFT
	LXI	H,MASKED
	MVI	M,'0'-1
SETM2	INR	M
	SUI	10
	JNC	SETM2
	ADI	10+'0'	;ADD BACK 10, + ASCII BIAS
	INX	H
	MOV	M,A
;
;END OF 11/06/MODS
;
;-->	COMP	MASKED,MSGFILE+9,2 ;SAME FILE?
	LXI	H,MASKED
	LXI	D,MSGFILE+9
	LXI	B,2
	CALL	COMPR
	JZ	NEXTNO	;YES, GET NEXT MSG #
;
;AT A NEW FILE - READ IT IN.
;
;-->	MOVE	MASKED,MSGFILE+9,2
	LXI	H,MASKED
	LXI	D,MSGFILE+9
	LXI	B,2
	CALL	MOVER
;-->	MOVE	MSGFILE,FCB+1,11
	LXI	H,MSGFILE
	LXI	D,FCB+1
	LXI	B,11
	CALL	MOVER
	XRA	A
	STA	FCBEXT
	STA	FCBRNO
;-->	CPM	OPEN,FCB,NOSAVE
	MVI	C,OPEN
	LXI	D,FCB
	CALL	BDOS
	INR	A
	JNZ	OPENOK
	CALL	ILPRT
	DB	'++FILE ',0
	CALL	NAMEPRT
	CALL	ILPRT
	DB	' NOT FOUND',CR,LF,0
	JMP	NEXTNO
;
;FILE OPENED OK - READ IT
;
OPENOK	LXI	H,0	;INIT EFCB..
	SHLD	EFCBCT	;..FOR READ
READLP	LXI	H,EFCB
	CALL	RDBYTE
	CPI	EOF
	JZ	NEXTNO	;TO NEXT
	CPI	7	;BELL HDR?
	JNZ	READLP
;
;POINTING TO A HEADER
;
	CALL	STORE	;STORE THE BELL
	LXI	H,NMSGS+4
	CALL	ADD1	;COUNT THE MSG
	CALL	LINE	;MOVE FIRST LINE
	CALL	LINE	;MOVE SECOND LINE
	JMP	READLP	;GO FOR NEXT HEADER
;
;GET NEXT MESSAGE NUMBER
;
NEXTNO	LXI	H,MSGNO+2
	CALL	ADD1	;BUMP
;IF AT 100, WE ARE DONE
	LDA	MSGNO
	CPI	'1'
	JNZ	NEXTFL
	LHLD	HDRPTR
	MVI	M,EOF
;
;CALCULATE AND PRINT # OF BYTES REMAINING
;
	XCHG		;END POINTER TO DE
REMAIN	LDA	7
	CMP	D
	JZ	ENDREM
	INX	D
	LXI	H,LEFT+4
	CALL	ADD1
	JMP	REMAIN
ENDREM	CALL	ILPRT
	DB	'Summary is in memory, with '
LEFT	DB	'      bytes open for more.',CR,LF
	DB	'There were '
NMSGS	DB	'      messages summarized',CR,LF
	DB	'Don''t forget to put the count '
	DB	'in the file NEXT, line 3,',CR,LF
	DB	'as the number of active messages '
	DB	'(5 digits, right justified)',CR,LF,0
;
SORT	CALL	ILPRT
	DB	'starting to write..',CR,LF,0
;-->	MOVE	SUMMARY,FCB,12
	LXI	H,SUMMARY
	LXI	D,FCB
	LXI	B,12
	CALL	MOVER
;-->	CPM	STDMA,80H,NOSAVE
	MVI	C,STDMA
	LXI	D,80H
	CALL	BDOS
	XRA	A
	STA	FCBRNO
	STA	FCBEXT
;-->	CPM	ERASE,FCB,NOSAVE
	MVI	C,ERASE
	LXI	D,FCB
	CALL	BDOS
;-->	CPM	MAKE,FCB,NOSAVE
	MVI	C,MAKE
	LXI	D,FCB
	CALL	BDOS
	INR	A
	JZ	SUMERR
SORTLP	CALL	FINDLOW	;FIND LOWEST MSG
	PUSH	H	;SAVE POINTER TO IT
	INX	H	;POINT TO FIRST DIGIT
	MOV	A,M
	CPI	0FFH
	JZ	DONE	;CLOSE UP, WE ARE DONE.
	DCX	H
	CALL	WRSUM	;WRITE A SUMMARY
	POP	H	;GET POINTER
	INX	H	;TO FIRST DIGIT
	MVI	M,0FFH	;MAKE IT HIGH, SHOW
;			 IT HAS BEEN DONE
	JMP	SORTLP
;
DONE	MVI	A,EOF	;PAD SECTOR W/EOF
	CALL	WRBYTE
	LDA	BUFPTR
	CPI	80H	;DID WE WRITE?
	JNZ	DONE
;-->	CPM	CLOSE,FCB,NOSAVE
	MVI	C,CLOSE
	LXI	D,FCB
	CALL	BDOS
	INR	A
	JNZ	DONEOK
	CALL	ERXIT
	DB	'++Error closing summary file++$'
DONEOK	CALL	ERXIT
	DB	'++DONE++$'
;
SUMERR	CALL	ERXIT
	DB	'++Can''t make SUMMARY file$'
;
;FIND THE LOWEST MSG NUMBER, RETURN IT IN HL
;
FINDLOW	LXI	H,HEADERS ;CURRENT LOWEST
	LXI	D,HEADERS
FINDLP	INX	D
	LDAX	D
	CPI	EOF	;DONE?
	RZ		;YES, HL = LOWEST
	CPI	7	;BELL ON NEXT?
	JNZ	FINDLP
;DE = ANOTHER HEADER
	INX	D	;TO 0FFH IF ITS THERE
	LDAX	D
	DCX	D
	INR	A	;WAS IT FF?
	JZ	FINDLP
	PUSH	H	;SAVE PREV LOWEST
	PUSH	D	;SAVE THIS ONE
;-->	COMP	,,6	;CHECK
	LXI	B,6
	CALL	COMPR
	POP	D
	POP	H
	JNC	FINDLP	;NOT NEW LOWEST
;GOT NEW LOWEST
	MOV	H,D
	MOV	L,E	;COPY TO HL
	JMP	FINDLP	;KEEP LOOKIN
;
;WRITE A SUMMARY
;
WRSUM	CALL	WRLINE
	CALL	WRLINE
	RET
;
WRLINE	MOV	A,M
	PUSH	H
	CALL	WRBYTE
	POP	H
	MOV	A,M
	INX	H
	CPI	LF
	JNZ	WRLINE
	RET
;
;BUMP AN ASCII NUMBER BY 1
;
ADD1	MOV	A,M
	ORI	'0'	;TURN BLANK INTO '0'
	INR	A
	MOV	M,A
	CPI	'9'+1	;CARRY?
	RNZ		;NO, RETURN
	MVI	M,'0'	;STUFF IN A 0
	DCX	H	;BACK UP TO CARRY
	JMP	ADD1
;
;READ 1 LINE OF THE HEADER
;
LINE	LXI	H,EFCB
	CALL	RDBYTE
	CPI	EOF
	JZ	FILERR
	CPI	LF	;END OF LINE?
	JZ	STORE	;YES, STORE IT, RETURN
	CALL	STORE	;STORE THE BYTE
	JMP	LINE
;
FILERR	CALL	ILPRT
	DB	'++FORMAT ERROR IN FILE ',0
	CALL	NAMEPRT
	CALL	ILPRT
	DB	CR,LF,'++SKIPPING FILE++',CR,LF,0
	JMP	NEXTNO
;
;PRINT THE FILENAME CURRENTLY BEING PROCESSED
;
NAMEPRT	MVI	A,'$'	;STUFF ENDING DELIM.
	STA	FCBEXT	;..FOR PRINT
;-->	CPM	PRINT,FCB+1,NOSAVE
	MVI	C,PRINT
	LXI	D,FCB+1
	CALL	BDOS
	RET
;
;WRITE A BYTE AT A TIME TO THE SUMMARY FILE
;
WRBYTE	LHLD	BUFPTR
	MOV	M,A
	INX	H
	SHLD	BUFPTR
	MOV	A,H
	CPI	1	;AT 100?
	RNZ
;
;HAVE TO WRITE
;
;-->	CPM	WRITE,FCB
	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,WRITE
	LXI	D,FCB
	CALL	BDOS
	POP	H
	POP	D
	POP	B
	ORA	A
	JNZ	WRERR
	LXI	H,80H
	SHLD	BUFPTR
	RET
;
WRERR	DB	'++ERROR WRITING SUMMAYY FILE++$'
;
;STORE A BYTE IN MEMORY, TEST FOR MEMORY FULL
;
STORE	LHLD	HDRPTR
	MOV	M,A
	INX	H
	SHLD	HDRPTR
	LDA	7
	CMP	H	;OUT OF MEMORY?
	RNZ		;..NO
	CALL	NAMEPRT
	CALL	ERXIT
	DB	'++INSUFFICIENT MEMORY TO BUILD SUMMARY++$'
;
;INLINE PRINT: CALL ILPRT WITH MESSAGE FOLLOWING,
;	0 TERMINATED.
;
ILPRT	XTHL		;SAVE HL, GET MSG
ILPLP	MOV	E,M
;-->	CPM	WRCON
	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,WRCON
	CALL	BDOS
	POP	H
	POP	D
	POP	B
	INX	H
	MOV	A,M
	ORA	A
	JNZ	ILPLP
	XTHL
	RET
;
;FOLLOWING FROM 'EQU8.LIB'---->
;
;117K TO DELETE TO "ERXIT" <<<<<<<<<<<<<<<<
;
;MOVE, COMPARE SUBROUTINES
;
MOVER	MOV	A,M
	STAX	D
	INX	H
	INX	D
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	MOVER
	RET
;
COMPR	LDAX	D
	CMP	M
	RNZ
	INX	D
	INX	H
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	COMPR
	RET
;
;	FROM EQU8.LIB: AS OF 05/06/79
;
;RDBYTE. NO REGISTERS SAVED.
;
;	HL POINTS TO EXTENDED FCB:
;
;	2 BYTE BUFFER ADDR
;	2 BYTE "BYTES LEFT" (INIT TO 0)
;	1 BYTE BUFFER SIZE (IN PAGES)
;	2 BYTE FCB ADDRESS
;
RDBYTE	MOV	E,M
	INX	H
	MOV	D,M	;DE=BUFFER ADDR
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M	;BC=BYTES LEFT
	MOV	A,B	;GET COUNT
	ORA	C
	JNZ	RDBNORD	;NO READ
;
	INX	H	;TO BUFFER SIZE
	MOV	A,M	;GET COUNT
	ADD	A	;MULTIPLY BY 2
	MOV	B,A	;SECTOR COUNT IN B
	INX	H	;TO FCB
	PUSH	H	;SAVE FCB POINTER
	MOV	A,M	;GET..
	INX	H	;..FCB..
	MOV	H,M	;..ADDR..
	MOV	L,A	;..TO HL
;
RDBLP	MVI	A,EOF	;GET EOF CHAR
	STAX	D	;SAVE IN CASE EOF
	PUSH	D	;SAVE DMA ADDR
	PUSH	H	;SAVE FCB ADDR
;-->	CPM	STDMA	;SET DMA ADDR
	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,STDMA
	CALL	BDOS
	POP	H
	POP	D
	POP	B
	POP	D	;GET FCB
;-->	CPM	READ
	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,READ
	CALL	BDOS
	POP	H
	POP	D
	POP	B
	ORA	A
	POP	H	;HL=DMA, DE=FCB
	JNZ	RDBRET	;GOT EOF
	MOV	A,L
	ADI	80H	;TO NEXT BUFF
	MOV	L,A
	MOV	A,H
	ACI	0
	MOV	H,A
	XCHG		;DMA TO DE, FCB TO HL
	DCR	B	;MORE SECTORS?
	JNZ	RDBLP	;YES, MORE
RDBRET	POP	H	;GET FCB POINTER
	DCX	H	;TO LENGTH
	MOV	A,M	;GET LENGTH
	DCX	H	;TO COUNT
	MOV	M,A	;SET PAGE COUNT
	DCX	H	;TO LO COUNT
	DCX	H	;TO HI FCB
	DCX	H	;TO EFCB START
	JMP	RDBYTE	;LOOP THRU AGAIN
;
RDBNORD	INX	H	;TO LENGTH
	MOV	A,M	;GET LENGTH (PAGES)
	XCHG		;BUFF TO HL
	ADD	H
	MOV	H,A	;HL = END OF BUFF
	MOV	A,L
	SUB	C
	MOV	L,A
	MOV	A,H
	SBB	B
	MOV	H,A	;HL = DATA POINTER
	MOV	A,M	;GET BYTE
	XCHG		;EFCB BACK TO HL
	CPI	EOF	;EOF?
	RZ		;YES, LEAVE POINTERS
	DCX	B	;DECR COUNT
	DCX	H	;BACK TO "BYTES LEFT"
	MOV	M,B
	DCX	H
	MOV	M,C	;STORE BACK COUNT
	RET
;
;SAMPLE EFCB:
;
;EFCB	DW	BUFF	;BUFFER ADDR
;	DW	0	;BYTES LEFT
;	DB	20	;BUFFER SIZE (IN PAGES)
;	DW	FCB	;FCB ADDRESS
;
;EXIT WITH ERROR MESSAGE
;
MSGEXIT	EQU	$	;EXIT W/"INFORMATIONAL" MSG
ERXIT	POP	D	;GET MSG
	MVI	C,PRINT
	CALL	BDOS
;
;EXIT
;
EXIT	JMP	0
;
;BUFFER POINTER FOR BYTE-AT-A-TIME WRITE
;
BUFPTR	DW	80H
;
;CURRENT MESSAGE NUMBER USED TO CALCULATE
;THE PROPER MESSAGE FILE TO OPEN
;
MSGNO	DB	'000'	;000-099
MASKED	DB	'00'	;LAST 2 DIGITS AFTER
;			 "ANI FILEMSK"
;
;THIS IS THE CURRENTLY OPENED MESSAGE FILE
;
MSGFILE	DB	'MESSAGE XXX'
;
;SUMMARY FILE (DISK VALUE MOVED TO FIRST BYTE)
;
SUMMARY	DB	0,'SUMMARY    '
;
;POINTER TO WHERE HEADER IS BEING STORED
;
HDRPTR	DW	HEADERS
;
;EXTENDED FCB FOR BUFFERED READING
;
EFCB	DW	BUFF	;BUFFER ADDR
EFCBCT	DW	0	;BYTES LEFT
	DB	BUFSZ/256 ;BUFFER SIZE (IN PAGES)
	DW	FCB	;FCB ADDRESS
;
	DS	100	;STACK AREA
STACK	EQU	$
;
;BUFFER FOR DISK READ
;
BUFF	DS	BUFSZ
;
;THE MESSAGE HEADERS IN AS-READ SEQUENCE
;
HEADERS	EQU	$
;
;BDOS/CBIOS EQUATES (VERSION 8)	
;
RDCON	EQU	1
WRCON	EQU	2
PRINT	EQU	9
RDCONBF	EQU	10
CONST	EQU	11
OPEN	EQU	15
CLOSE	EQU	16
SRCHF	EQU	17
SRCHN	EQU	18
ERASE	EQU	19
READ	EQU	20
WRITE	EQU	21
MAKE	EQU	22
REN	EQU	23
STDMA	EQU	26
BDOS	EQU	5
FCB	EQU	5CH 
FCB2	EQU	6CH
FCBEXT	EQU	FCB+12
FCBRNO	EQU	FCB+32
