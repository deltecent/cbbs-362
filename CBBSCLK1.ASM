;CBBS V3.6.2 	CBBSCLK1.ASM - COMPUPRO SS1 CLOCK FUNCTIONS
;08/14/20 19:09:42
; LINKED FROM CBBSDISK ONLY IF CLOCK1=TRUE
;
;	LINKS TO CBBSSUB1
;
;	O O O	O	O   O	  O
;	O	O	O  O	O O
; CBBS	O	O	OOO	  O  	.ASM
;	O	O	O  O	  O  
;	O O O	O O O	O   O	O O O
;
;====>	HISTORICAL COMMENTS written to various 
;	"History.xxx" files.
;
;	----------------
;COMPUPRO SS1 CLOCK BOARD EQUATES
;
SS1BASE	EQU	050H		;CLOCK BASE ADDRESS
SS1CMD	EQU	SS1BASE+10	;CLOCK COMMAND PORT
SS1DATA	EQU	SS1BASE+11	;CLOCK DATA PORT
SS1READ	EQU	10H		;READ BIT PATTERN
SS1WRT	EQU	20H		;WRITE BIT PATTERN
SS1HOLD	EQU	40H		;HOLD BIT PATTERN

;'T' COMMAND: PRINTS DATE, TIME, ELAPSED TIME
;
PRDTIME	CALL	PRETIME
	JMP	FUNCT
;
;DATE/TIME PRINT SUBROUTINE
;
PRTIME	LXI	H,ANSWER ;STORE IT HERE
	PUSH	H
	CALL	RDDATE
	MVI	M,' '
	INX	H
	JC	CLKINOP
	CALL	RDTIME	;GET TIME
	MVI	M,0
	POP	H
	MOV	A,M	;GET HI
	CPI	'3'	;VALID?
	JNC	CLKINO1
	CALL	TYPEM0	;TYPE DATE
	CALL	CRLF
	ORA	A	;SHOW CLOCK IS OK
	RET
;
CLKINOP	POP	H	;FIXUP STACK
CLKINO1	CALL	ILPRT
	DB	'++Clock inop++',CR,LF,0
	STC		;SHOW ERROR
	RET
;
;PRETIME: PRINTS CURRENT AND ELAPSED TIME
;
PRETIME	CALL	PRTIME
	RC		;RET IF NO CLOCK
	LXI	H,ANSWER
	PUSH	H
	CALL	RDTIME
	POP	H
	CALL	CONVTBI	;HL=BINARY CURR TIME
	PUSH	H
	LXI	H,LGINTIM ;GET LOGGED IN TIME
	CALL	CONVTBI	;HL=LOGGED IN TIME
	POP	D	;DE=CURR TIME
;SUBTRACT TO GET ELAPSED MINUTES
	MOV	A,E
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	RAL		;CARRY IF NEG
	JNC	PRETOK
;ELAPSED TIME IS NEGATIVE - ADD 24 HOURS
	LXI	D,24*60	;1 DAY OF MINUTES
	DAD	D
PRETOK	MOV	A,H
	ORA	A	;>255 MINUTES?
	JNZ	PREBAD
	MOV	A,L	;GET TIME
	CPI	120	;>2 HRS? PROB. BAD.
	JNC	PREBAD
;E.T. IS VALID, PRINT IT
	PUSH	PSW
	CALL	ILPRT
	DB	'Connect time ',0
	POP	PSW
	CALL	PRDEC
	CALL	ILPRT
	DB	' minutes',CR,LF,0
	RET
;
PREBAD	CALL	ILPRT
	DB	'Unable to calc connect time',cr,lf,0
	RET
;
;WRITE DATE, TIME, ELAPSED TIME
;
WRETIME	CALL	PRETIME	;PRINT & CALC ELAPSED
	RC		;INVALID CLOCK
	LXI	H,decnum
;
;	skip over leading spaces (02/27/83 mod)
;
wretsk	mov	a,m
	inx	h
	cpi	' '
	jz	wretsk
	dcx	h
	JMP	WRVAR	;WRITE ELAPSED, ","
;
;WRITE DATE AND TIME TO CURRENTLY OPEN
;FILE (USUALLY LOG, BUT SOMETIMES "NOTES")
;
WRTIME	LXI	H,ANSWER ;WORK AREA
	PUSH	H
	CALL	RDDATE
	MVI	M,0DH
	POP	H
	RC
	MOV	A,M
	CPI	'2'	;VALIDATE
	CMC		;	THE
	RC		;	TIME
	PUSH	H
	CALL	WRVARC	;WRITE DATE
	POP	H
	PUSH	H
	CALL	RDTIME
	MVI	M,0DH
	POP	H
	JMP	WRVARC	;WRITE DATE
;
;RDTIME - STORES THE TIME "HH:MM:SS " INTO
;	FIELD POINTED TO BY HL.  UPON RETURN,
;	HL POINTS PAST LAST BYTE.
;
RDTIME	CALL	CLKINIT
	RC
	LXI	D,256*5+':'	;HOURS 10 DIGIT
	CALL	CLKDIG2
	CALL	CLKDIG2
	CALL	CLKDIG2
	CALL	CLKCONT
	DCX	H
	ORA	A	;SHOW READ OK
	RET
;
;RDDATE - STORES THE DATE "MM/DD/YY " INTO
;	FIELD POINTED TO BY HL.  UPON RETURN,
;	HL POINTS PAST LAST BYTE.
;
RDDATE	CALL	CLKINIT
	RC
	LXI	D,256*10+'/'	;MONTHS 10 DIGIT
	CALL	CLKDIG2
	CALL	CLKDIG2
	MVI	D,12		;YEARS 10 DIGIT
	CALL	CLKDIG2
	CALL	CLKCONT		;RESTART CLOCK
	DCX	H
	ORA	A
	RET
;
;STORE 2 CONSECUTIVE DATE/TIME DIGITS
;
CLKDIG2	CALL	CLKDIG
	CALL	CLKDIG
	MOV	M,E
	INX	H
	RET
;
;====>	CLKDIG:	GETS A SINGLE DIGIT FROM THE CLOCK TO MEMORY
;
CLKDIG	MOV	A,D		;GET DIGIT SELECT
	ADI	SS1READ		;ADD READ BIT
	DCR	D		;SETUP FOR NEXT DIGIT
	OUT	SS1CMD		;ASK FOR IT
	NOP			;NEEDED @ 5MHz
	CPI	5+SS1READ	;HOURS (HAVE TO MASK)?
	IN	SS1DATA		;READ IT (PRESERVES CPI 5 TEST)
	JNZ	CLKN5		;	NOT DIGIT 5, SKIP MASKING
	ANI	03H		;	KILL NON-DIGIT BITS
CLKN5	ADI	'0'		;MAKE PRINTABLE
	MOV	M,A		;STORE IT
	INX	H		;BUMP TO NEXT
	RET			;	AND RETURN
;
;====>	CLKINIT	INITIALIZES THE CLOCK FOR READ
;	RETURNS CARRY IF THERE IS NO CLOCK
;
CLKINIT	IN	SS1DATA	;CLOCK EXIST?
	INR	A
	STC		;RETURN CARRY
	RZ		;	IF NO CLOCK

	ORA	A	;CLOCK OK
	RET
;
;====>	CLKCONT	CONTINUE CLOCK
;
CLKCONT	RET		;END OF CLOCK ROUTINES
;
;SUBROUTINE TO CONVERT ASCII TIME TO BINARY
;
;USED TO PRINT CALLER'S ELAPSED TIME
;
;	HL POINTS TO "HH:MM"
;
;	BINARY MINUTES RETURNED IN HL
;
CONVTBI	MOV	B,H	;POINTER
	MOV	C,L	;	TO BC
	LXI	H,0	;INIT ANS
	CALL	CT10F	;GET DIGIT
	CALL	CT10	;X 10 + NEXT DIGIT
	INX	B	;SKIP COLON
	CALL	CT6	;X 6 + NEXT DIGIT
;
;FALL INTO CB10, TO MULTIPLY BY 10
;AND GET LAST DIGIT
;
;MULTIPLY HL BY 10 AND ADD IN BINARY
;VALUE OF NEXT ASCII DIGIT POINTED TO BY BC.
;
CT10	MOV	D,H	;SET UP
	MOV	E,L	;	FOR MULT
	DAD	H	;X2
	DAD	H	;X4
	DAD	D	;X5
	DAD	H	;X10
;
;ENTER HERE TO GET FIRST DIGIT
;
CT10F	LDAX	B	;GET DIGIT
	INX	B	;TO NEXT DIGIT
	SUI	'0'	;MAKE BINARY
	ADD	L	;ADD TO LOW
	MOV	L,A	;SAVE BACK
	RNC
	INR	H	;ADD IN CARRY
	RET
;
;ROUTINE TO MULTIPLY HL BY 60, AND ADD
;IN NEXT DIGIT
;
CT6	MOV	D,H	;SET UP
	MOV	E,L	;	FOR MULT
	DAD	H	;X2
	DAD	D	;X3
	DAD	H	;X6
	JMP	CT10F	;GET DIGIT
;
	ENDIF		;CLOCKS
;
 	LINK	CBBSSUB1 ;TO NEXT .ASM FILE
